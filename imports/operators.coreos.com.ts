// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * CatalogSource is a repository of CSVs, CRDs, and operator packages.
 *
 * @schema CatalogSource
 */
export class CatalogSource extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CatalogSource"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operators.coreos.com/v1alpha1',
    kind: 'CatalogSource',
  }

  /**
   * Renders a Kubernetes manifest for "CatalogSource".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CatalogSourceProps): any {
    return {
      ...CatalogSource.GVK,
      ...toJson_CatalogSourceProps(props),
    };
  }

  /**
   * Defines a "CatalogSource" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CatalogSourceProps) {
    super(scope, id, {
      ...CatalogSource.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CatalogSource.GVK,
      ...toJson_CatalogSourceProps(resolved),
    };
  }
}

/**
 * CatalogSource is a repository of CSVs, CRDs, and operator packages.
 *
 * @schema CatalogSource
 */
export interface CatalogSourceProps {
  /**
   * @schema CatalogSource#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * @schema CatalogSource#spec
   */
  readonly spec: CatalogSourceSpec;

}

/**
 * Converts an object of type 'CatalogSourceProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceProps(obj: CatalogSourceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CatalogSourceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema CatalogSourceSpec
 */
export interface CatalogSourceSpec {
  /**
   * Address is a host that OLM can use to connect to a pre-existing registry.
   * Format: <registry-host or ip>:<port>
   * Only used when SourceType = SourceTypeGrpc.
   * Ignored when the Image field is set.
   *
   * @schema CatalogSourceSpec#address
   */
  readonly address?: string;

  /**
   * ConfigMap is the name of the ConfigMap to be used to back a configmap-server registry.
   * Only used when SourceType = SourceTypeConfigmap or SourceTypeInternal.
   *
   * @schema CatalogSourceSpec#configMap
   */
  readonly configMap?: string;

  /**
   * @schema CatalogSourceSpec#description
   */
  readonly description?: string;

  /**
   * Metadata
   *
   * @schema CatalogSourceSpec#displayName
   */
  readonly displayName?: string;

  /**
   * GrpcPodConfig exposes different overrides for the pod spec of the CatalogSource Pod.
   * Only used when SourceType = SourceTypeGrpc and Image is set.
   *
   * @schema CatalogSourceSpec#grpcPodConfig
   */
  readonly grpcPodConfig?: CatalogSourceSpecGrpcPodConfig;

  /**
   * @schema CatalogSourceSpec#icon
   */
  readonly icon?: CatalogSourceSpecIcon;

  /**
   * Image is an operator-registry container image to instantiate a registry-server with.
   * Only used when SourceType = SourceTypeGrpc.
   * If present, the address field is ignored.
   *
   * @schema CatalogSourceSpec#image
   */
  readonly image?: string;

  /**
   * Priority field assigns a weight to the catalog source to prioritize them so that it can be consumed by the dependency resolver.
   * Usage:
   * Higher weight indicates that this catalog source is preferred over lower weighted catalog sources during dependency resolution.
   * The range of the priority value can go from positive to negative in the range of int32.
   * The default value to a catalog source with unassigned priority would be 0.
   * The catalog source with the same priority values will be ranked lexicographically based on its name.
   *
   * @schema CatalogSourceSpec#priority
   */
  readonly priority?: number;

  /**
   * @schema CatalogSourceSpec#publisher
   */
  readonly publisher?: string;

  /**
   * Secrets represent set of secrets that can be used to access the contents of the catalog.
   * It is best to keep this list small, since each will need to be tried for every catalog entry.
   *
   * @schema CatalogSourceSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SourceType is the type of source
   *
   * @schema CatalogSourceSpec#sourceType
   */
  readonly sourceType: string;

  /**
   * UpdateStrategy defines how updated catalog source images can be discovered
   * Consists of an interval that defines polling duration and an embedded strategy type
   *
   * @schema CatalogSourceSpec#updateStrategy
   */
  readonly updateStrategy?: CatalogSourceSpecUpdateStrategy;

}

/**
 * Converts an object of type 'CatalogSourceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpec(obj: CatalogSourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'configMap': obj.configMap,
    'description': obj.description,
    'displayName': obj.displayName,
    'grpcPodConfig': toJson_CatalogSourceSpecGrpcPodConfig(obj.grpcPodConfig),
    'icon': toJson_CatalogSourceSpecIcon(obj.icon),
    'image': obj.image,
    'priority': obj.priority,
    'publisher': obj.publisher,
    'secrets': obj.secrets?.map(y => y),
    'sourceType': obj.sourceType,
    'updateStrategy': toJson_CatalogSourceSpecUpdateStrategy(obj.updateStrategy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GrpcPodConfig exposes different overrides for the pod spec of the CatalogSource Pod.
 * Only used when SourceType = SourceTypeGrpc and Image is set.
 *
 * @schema CatalogSourceSpecGrpcPodConfig
 */
export interface CatalogSourceSpecGrpcPodConfig {
  /**
   * Affinity is the catalog source's pod's affinity.
   *
   * @schema CatalogSourceSpecGrpcPodConfig#affinity
   */
  readonly affinity?: CatalogSourceSpecGrpcPodConfigAffinity;

  /**
   * ExtractContent configures the gRPC catalog Pod to extract catalog metadata from the provided index image and
   * use a well-known version of the `opm` server to expose it. The catalog index image that this CatalogSource is
   * configured to use *must* be using the file-based catalogs in order to utilize this feature.
   *
   * @schema CatalogSourceSpecGrpcPodConfig#extractContent
   */
  readonly extractContent?: CatalogSourceSpecGrpcPodConfigExtractContent;

  /**
   * MemoryTarget configures the $GOMEMLIMIT value for the gRPC catalog Pod. This is a soft memory limit for the server,
   * which the runtime will attempt to meet but makes no guarantees that it will do so. If this value is set, the Pod
   * will have the following modifications made to the container running the server:
   * - the $GOMEMLIMIT environment variable will be set to this value in bytes
   * - the memory request will be set to this value
   *
   * This field should be set if it's desired to reduce the footprint of a catalog server as much as possible, or if
   * a catalog being served is very large and needs more than the default allocation. If your index image has a file-
   * system cache, determine a good approximation for this value by doubling the size of the package cache at
   * /tmp/cache/cache/packages.json in the index image.
   *
   * This field is best-effort; if unset, no default will be used and no Pod memory limit or $GOMEMLIMIT value will be set.
   *
   * @schema CatalogSourceSpecGrpcPodConfig#memoryTarget
   */
  readonly memoryTarget?: CatalogSourceSpecGrpcPodConfigMemoryTarget;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   *
   * @schema CatalogSourceSpecGrpcPodConfig#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, indicates the pod's priority.
   * If not specified, the pod priority will be default or zero if there is no
   * default.
   *
   * @schema CatalogSourceSpecGrpcPodConfig#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * SecurityContextConfig can be one of `legacy` or `restricted`. The CatalogSource's pod is either injected with the
   * right pod.spec.securityContext and pod.spec.container[*].securityContext values to allow the pod to run in Pod
   * Security Admission (PSA) `restricted` mode, or doesn't set these values at all, in which case the pod can only be
   * run in PSA `baseline` or `privileged` namespaces. If the SecurityContextConfig is unspecified, the mode will be
   * determined by the namespace's PSA configuration. If the namespace is enforcing `restricted` mode, then the pod
   * will be configured as if `restricted` was specified. Otherwise, it will be configured as if `legacy` was
   * specified. Specifying a value other than `legacy` or `restricted` result in a validation error. When using older
   * catalog images, which can not run in `restricted` mode, the SecurityContextConfig should be set to `legacy`.
   *
   * More information about PSA can be found here: https://kubernetes.io/docs/concepts/security/pod-security-admission/
   *
   * @schema CatalogSourceSpecGrpcPodConfig#securityContextConfig
   */
  readonly securityContextConfig?: CatalogSourceSpecGrpcPodConfigSecurityContextConfig;

  /**
   * Tolerations are the catalog source's pod's tolerations.
   *
   * @schema CatalogSourceSpecGrpcPodConfig#tolerations
   */
  readonly tolerations?: CatalogSourceSpecGrpcPodConfigTolerations[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfig(obj: CatalogSourceSpecGrpcPodConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_CatalogSourceSpecGrpcPodConfigAffinity(obj.affinity),
    'extractContent': toJson_CatalogSourceSpecGrpcPodConfigExtractContent(obj.extractContent),
    'memoryTarget': obj.memoryTarget?.value,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'priorityClassName': obj.priorityClassName,
    'securityContextConfig': obj.securityContextConfig,
    'tolerations': obj.tolerations?.map(y => toJson_CatalogSourceSpecGrpcPodConfigTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema CatalogSourceSpecIcon
 */
export interface CatalogSourceSpecIcon {
  /**
   * @schema CatalogSourceSpecIcon#base64data
   */
  readonly base64Data: string;

  /**
   * @schema CatalogSourceSpecIcon#mediatype
   */
  readonly mediatype: string;

}

/**
 * Converts an object of type 'CatalogSourceSpecIcon' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecIcon(obj: CatalogSourceSpecIcon | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base64data': obj.base64Data,
    'mediatype': obj.mediatype,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpdateStrategy defines how updated catalog source images can be discovered
 * Consists of an interval that defines polling duration and an embedded strategy type
 *
 * @schema CatalogSourceSpecUpdateStrategy
 */
export interface CatalogSourceSpecUpdateStrategy {
  /**
   * @schema CatalogSourceSpecUpdateStrategy#registryPoll
   */
  readonly registryPoll?: CatalogSourceSpecUpdateStrategyRegistryPoll;

}

/**
 * Converts an object of type 'CatalogSourceSpecUpdateStrategy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecUpdateStrategy(obj: CatalogSourceSpecUpdateStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'registryPoll': toJson_CatalogSourceSpecUpdateStrategyRegistryPoll(obj.registryPoll),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Affinity is the catalog source's pod's affinity.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinity
 */
export interface CatalogSourceSpecGrpcPodConfigAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinity#nodeAffinity
   */
  readonly nodeAffinity?: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinity#podAffinity
   */
  readonly podAffinity?: CatalogSourceSpecGrpcPodConfigAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinity(obj: CatalogSourceSpecGrpcPodConfigAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExtractContent configures the gRPC catalog Pod to extract catalog metadata from the provided index image and
 * use a well-known version of the `opm` server to expose it. The catalog index image that this CatalogSource is
 * configured to use *must* be using the file-based catalogs in order to utilize this feature.
 *
 * @schema CatalogSourceSpecGrpcPodConfigExtractContent
 */
export interface CatalogSourceSpecGrpcPodConfigExtractContent {
  /**
   * CacheDir is the (optional) directory storing the pre-calculated API cache.
   *
   * @schema CatalogSourceSpecGrpcPodConfigExtractContent#cacheDir
   */
  readonly cacheDir?: string;

  /**
   * CatalogDir is the directory storing the file-based catalog contents.
   *
   * @schema CatalogSourceSpecGrpcPodConfigExtractContent#catalogDir
   */
  readonly catalogDir: string;

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigExtractContent' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigExtractContent(obj: CatalogSourceSpecGrpcPodConfigExtractContent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cacheDir': obj.cacheDir,
    'catalogDir': obj.catalogDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MemoryTarget configures the $GOMEMLIMIT value for the gRPC catalog Pod. This is a soft memory limit for the server,
 * which the runtime will attempt to meet but makes no guarantees that it will do so. If this value is set, the Pod
 * will have the following modifications made to the container running the server:
 * - the $GOMEMLIMIT environment variable will be set to this value in bytes
 * - the memory request will be set to this value
 *
 * This field should be set if it's desired to reduce the footprint of a catalog server as much as possible, or if
 * a catalog being served is very large and needs more than the default allocation. If your index image has a file-
 * system cache, determine a good approximation for this value by doubling the size of the package cache at
 * /tmp/cache/cache/packages.json in the index image.
 *
 * This field is best-effort; if unset, no default will be used and no Pod memory limit or $GOMEMLIMIT value will be set.
 *
 * @schema CatalogSourceSpecGrpcPodConfigMemoryTarget
 */
export class CatalogSourceSpecGrpcPodConfigMemoryTarget {
  public static fromNumber(value: number): CatalogSourceSpecGrpcPodConfigMemoryTarget {
    return new CatalogSourceSpecGrpcPodConfigMemoryTarget(value);
  }
  public static fromString(value: string): CatalogSourceSpecGrpcPodConfigMemoryTarget {
    return new CatalogSourceSpecGrpcPodConfigMemoryTarget(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * SecurityContextConfig can be one of `legacy` or `restricted`. The CatalogSource's pod is either injected with the
 * right pod.spec.securityContext and pod.spec.container[*].securityContext values to allow the pod to run in Pod
 * Security Admission (PSA) `restricted` mode, or doesn't set these values at all, in which case the pod can only be
 * run in PSA `baseline` or `privileged` namespaces. If the SecurityContextConfig is unspecified, the mode will be
 * determined by the namespace's PSA configuration. If the namespace is enforcing `restricted` mode, then the pod
 * will be configured as if `restricted` was specified. Otherwise, it will be configured as if `legacy` was
 * specified. Specifying a value other than `legacy` or `restricted` result in a validation error. When using older
 * catalog images, which can not run in `restricted` mode, the SecurityContextConfig should be set to `legacy`.
 *
 * More information about PSA can be found here: https://kubernetes.io/docs/concepts/security/pod-security-admission/
 *
 * @schema CatalogSourceSpecGrpcPodConfigSecurityContextConfig
 */
export enum CatalogSourceSpecGrpcPodConfigSecurityContextConfig {
  /** legacy */
  LEGACY = "legacy",
  /** restricted */
  RESTRICTED = "restricted",
}

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema CatalogSourceSpecGrpcPodConfigTolerations
 */
export interface CatalogSourceSpecGrpcPodConfigTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema CatalogSourceSpecGrpcPodConfigTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema CatalogSourceSpecGrpcPodConfigTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema CatalogSourceSpecGrpcPodConfigTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema CatalogSourceSpecGrpcPodConfigTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema CatalogSourceSpecGrpcPodConfigTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigTolerations(obj: CatalogSourceSpecGrpcPodConfigTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema CatalogSourceSpecUpdateStrategyRegistryPoll
 */
export interface CatalogSourceSpecUpdateStrategyRegistryPoll {
  /**
   * Interval is used to determine the time interval between checks of the latest catalog source version.
   * The catalog operator polls to see if a new version of the catalog source is available.
   * If available, the latest image is pulled and gRPC traffic is directed to the latest catalog source.
   *
   * @schema CatalogSourceSpecUpdateStrategyRegistryPoll#interval
   */
  readonly interval?: string;

}

/**
 * Converts an object of type 'CatalogSourceSpecUpdateStrategyRegistryPoll' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecUpdateStrategyRegistryPoll(obj: CatalogSourceSpecUpdateStrategyRegistryPoll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinity
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinity(obj: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinity
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinity(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinity
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinity(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: CatalogSourceSpecGrpcPodConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: CatalogSourceSpecGrpcPodConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ClusterServiceVersion is a Custom Resource of type `ClusterServiceVersionSpec`.
 *
 * @schema ClusterServiceVersion
 */
export class ClusterServiceVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterServiceVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operators.coreos.com/v1alpha1',
    kind: 'ClusterServiceVersion',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterServiceVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterServiceVersionProps): any {
    return {
      ...ClusterServiceVersion.GVK,
      ...toJson_ClusterServiceVersionProps(props),
    };
  }

  /**
   * Defines a "ClusterServiceVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterServiceVersionProps) {
    super(scope, id, {
      ...ClusterServiceVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterServiceVersion.GVK,
      ...toJson_ClusterServiceVersionProps(resolved),
    };
  }
}

/**
 * ClusterServiceVersion is a Custom Resource of type `ClusterServiceVersionSpec`.
 *
 * @schema ClusterServiceVersion
 */
export interface ClusterServiceVersionProps {
  /**
   * @schema ClusterServiceVersion#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * ClusterServiceVersionSpec declarations tell OLM how to install an operator
   * that can manage apps for a given version.
   *
   * @schema ClusterServiceVersion#spec
   */
  readonly spec: ClusterServiceVersionSpec;

}

/**
 * Converts an object of type 'ClusterServiceVersionProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionProps(obj: ClusterServiceVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterServiceVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterServiceVersionSpec declarations tell OLM how to install an operator
 * that can manage apps for a given version.
 *
 * @schema ClusterServiceVersionSpec
 */
export interface ClusterServiceVersionSpec {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata.
   *
   * @schema ClusterServiceVersionSpec#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * APIServiceDefinitions declares all of the extension apis managed or required by
   * an operator being ran by ClusterServiceVersion.
   *
   * @schema ClusterServiceVersionSpec#apiservicedefinitions
   */
  readonly apiservicedefinitions?: ClusterServiceVersionSpecApiservicedefinitions;

  /**
   * Cleanup specifies the cleanup behaviour when the CSV gets deleted
   *
   * @schema ClusterServiceVersionSpec#cleanup
   */
  readonly cleanup?: ClusterServiceVersionSpecCleanup;

  /**
   * CustomResourceDefinitions declares all of the CRDs managed or required by
   * an operator being ran by ClusterServiceVersion.
   *
   * If the CRD is present in the Owned list, it is implicitly required.
   *
   * @schema ClusterServiceVersionSpec#customresourcedefinitions
   */
  readonly customresourcedefinitions?: ClusterServiceVersionSpecCustomresourcedefinitions;

  /**
   * Description of the operator. Can include the features, limitations or use-cases of the
   * operator.
   *
   * @schema ClusterServiceVersionSpec#description
   */
  readonly description?: string;

  /**
   * The name of the operator in display format.
   *
   * @schema ClusterServiceVersionSpec#displayName
   */
  readonly displayName: string;

  /**
   * The icon for this operator.
   *
   * @schema ClusterServiceVersionSpec#icon
   */
  readonly icon?: ClusterServiceVersionSpecIcon[];

  /**
   * NamedInstallStrategy represents the block of an ClusterServiceVersion resource
   * where the install strategy is specified.
   *
   * @schema ClusterServiceVersionSpec#install
   */
  readonly install: ClusterServiceVersionSpecInstall;

  /**
   * InstallModes specify supported installation types
   *
   * @schema ClusterServiceVersionSpec#installModes
   */
  readonly installModes?: ClusterServiceVersionSpecInstallModes[];

  /**
   * A list of keywords describing the operator.
   *
   * @schema ClusterServiceVersionSpec#keywords
   */
  readonly keywords?: string[];

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects.
   *
   * @schema ClusterServiceVersionSpec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * A list of links related to the operator.
   *
   * @schema ClusterServiceVersionSpec#links
   */
  readonly links?: ClusterServiceVersionSpecLinks[];

  /**
   * A list of organizational entities maintaining the operator.
   *
   * @schema ClusterServiceVersionSpec#maintainers
   */
  readonly maintainers?: ClusterServiceVersionSpecMaintainers[];

  /**
   * @schema ClusterServiceVersionSpec#maturity
   */
  readonly maturity?: string;

  /**
   * @schema ClusterServiceVersionSpec#minKubeVersion
   */
  readonly minKubeVersion?: string;

  /**
   * @schema ClusterServiceVersionSpec#nativeAPIs
   */
  readonly nativeApIs?: ClusterServiceVersionSpecNativeApIs[];

  /**
   * The publishing entity behind the operator.
   *
   * @schema ClusterServiceVersionSpec#provider
   */
  readonly provider?: ClusterServiceVersionSpecProvider;

  /**
   * List any related images, or other container images that your Operator might require to perform their functions.
   * This list should also include operand images as well. All image references should be specified by
   * digest (SHA) and not by tag. This field is only used during catalog creation and plays no part in cluster runtime.
   *
   * @schema ClusterServiceVersionSpec#relatedImages
   */
  readonly relatedImages?: ClusterServiceVersionSpecRelatedImages[];

  /**
   * The name of a CSV this one replaces. Should match the `metadata.Name` field of the old CSV.
   *
   * @schema ClusterServiceVersionSpec#replaces
   */
  readonly replaces?: string;

  /**
   * Label selector for related resources.
   *
   * @schema ClusterServiceVersionSpec#selector
   */
  readonly selector?: ClusterServiceVersionSpecSelector;

  /**
   * The name(s) of one or more CSV(s) that should be skipped in the upgrade graph.
   * Should match the `metadata.Name` field of the CSV that should be skipped.
   * This field is only used during catalog creation and plays no part in cluster runtime.
   *
   * @schema ClusterServiceVersionSpec#skips
   */
  readonly skips?: string[];

  /**
   * @schema ClusterServiceVersionSpec#version
   */
  readonly version?: string;

  /**
   * @schema ClusterServiceVersionSpec#webhookdefinitions
   */
  readonly webhookdefinitions?: ClusterServiceVersionSpecWebhookdefinitions[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpec(obj: ClusterServiceVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'apiservicedefinitions': toJson_ClusterServiceVersionSpecApiservicedefinitions(obj.apiservicedefinitions),
    'cleanup': toJson_ClusterServiceVersionSpecCleanup(obj.cleanup),
    'customresourcedefinitions': toJson_ClusterServiceVersionSpecCustomresourcedefinitions(obj.customresourcedefinitions),
    'description': obj.description,
    'displayName': obj.displayName,
    'icon': obj.icon?.map(y => toJson_ClusterServiceVersionSpecIcon(y)),
    'install': toJson_ClusterServiceVersionSpecInstall(obj.install),
    'installModes': obj.installModes?.map(y => toJson_ClusterServiceVersionSpecInstallModes(y)),
    'keywords': obj.keywords?.map(y => y),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'links': obj.links?.map(y => toJson_ClusterServiceVersionSpecLinks(y)),
    'maintainers': obj.maintainers?.map(y => toJson_ClusterServiceVersionSpecMaintainers(y)),
    'maturity': obj.maturity,
    'minKubeVersion': obj.minKubeVersion,
    'nativeAPIs': obj.nativeApIs?.map(y => toJson_ClusterServiceVersionSpecNativeApIs(y)),
    'provider': toJson_ClusterServiceVersionSpecProvider(obj.provider),
    'relatedImages': obj.relatedImages?.map(y => toJson_ClusterServiceVersionSpecRelatedImages(y)),
    'replaces': obj.replaces,
    'selector': toJson_ClusterServiceVersionSpecSelector(obj.selector),
    'skips': obj.skips?.map(y => y),
    'version': obj.version,
    'webhookdefinitions': obj.webhookdefinitions?.map(y => toJson_ClusterServiceVersionSpecWebhookdefinitions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIServiceDefinitions declares all of the extension apis managed or required by
 * an operator being ran by ClusterServiceVersion.
 *
 * @schema ClusterServiceVersionSpecApiservicedefinitions
 */
export interface ClusterServiceVersionSpecApiservicedefinitions {
  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitions#owned
   */
  readonly owned?: ClusterServiceVersionSpecApiservicedefinitionsOwned[];

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitions#required
   */
  readonly required?: ClusterServiceVersionSpecApiservicedefinitionsRequired[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecApiservicedefinitions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecApiservicedefinitions(obj: ClusterServiceVersionSpecApiservicedefinitions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'owned': obj.owned?.map(y => toJson_ClusterServiceVersionSpecApiservicedefinitionsOwned(y)),
    'required': obj.required?.map(y => toJson_ClusterServiceVersionSpecApiservicedefinitionsRequired(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cleanup specifies the cleanup behaviour when the CSV gets deleted
 *
 * @schema ClusterServiceVersionSpecCleanup
 */
export interface ClusterServiceVersionSpecCleanup {
  /**
   * @schema ClusterServiceVersionSpecCleanup#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecCleanup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecCleanup(obj: ClusterServiceVersionSpecCleanup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CustomResourceDefinitions declares all of the CRDs managed or required by
 * an operator being ran by ClusterServiceVersion.
 *
 * If the CRD is present in the Owned list, it is implicitly required.
 *
 * @schema ClusterServiceVersionSpecCustomresourcedefinitions
 */
export interface ClusterServiceVersionSpecCustomresourcedefinitions {
  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitions#owned
   */
  readonly owned?: ClusterServiceVersionSpecCustomresourcedefinitionsOwned[];

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitions#required
   */
  readonly required?: ClusterServiceVersionSpecCustomresourcedefinitionsRequired[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecCustomresourcedefinitions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecCustomresourcedefinitions(obj: ClusterServiceVersionSpecCustomresourcedefinitions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'owned': obj.owned?.map(y => toJson_ClusterServiceVersionSpecCustomresourcedefinitionsOwned(y)),
    'required': obj.required?.map(y => toJson_ClusterServiceVersionSpecCustomresourcedefinitionsRequired(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterServiceVersionSpecIcon
 */
export interface ClusterServiceVersionSpecIcon {
  /**
   * @schema ClusterServiceVersionSpecIcon#base64data
   */
  readonly base64Data: string;

  /**
   * @schema ClusterServiceVersionSpecIcon#mediatype
   */
  readonly mediatype: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecIcon' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecIcon(obj: ClusterServiceVersionSpecIcon | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base64data': obj.base64Data,
    'mediatype': obj.mediatype,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NamedInstallStrategy represents the block of an ClusterServiceVersion resource
 * where the install strategy is specified.
 *
 * @schema ClusterServiceVersionSpecInstall
 */
export interface ClusterServiceVersionSpecInstall {
  /**
   * StrategyDetailsDeployment represents the parsed details of a Deployment
   * InstallStrategy.
   *
   * @schema ClusterServiceVersionSpecInstall#spec
   */
  readonly spec?: ClusterServiceVersionSpecInstallSpec;

  /**
   * @schema ClusterServiceVersionSpecInstall#strategy
   */
  readonly strategy: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstall' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstall(obj: ClusterServiceVersionSpecInstall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'spec': toJson_ClusterServiceVersionSpecInstallSpec(obj.spec),
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InstallMode associates an InstallModeType with a flag representing if the CSV supports it
 *
 * @schema ClusterServiceVersionSpecInstallModes
 */
export interface ClusterServiceVersionSpecInstallModes {
  /**
   * @schema ClusterServiceVersionSpecInstallModes#supported
   */
  readonly supported: boolean;

  /**
   * InstallModeType is a supported type of install mode for CSV installation
   *
   * @schema ClusterServiceVersionSpecInstallModes#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallModes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallModes(obj: ClusterServiceVersionSpecInstallModes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'supported': obj.supported,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterServiceVersionSpecLinks
 */
export interface ClusterServiceVersionSpecLinks {
  /**
   * @schema ClusterServiceVersionSpecLinks#name
   */
  readonly name?: string;

  /**
   * @schema ClusterServiceVersionSpecLinks#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecLinks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecLinks(obj: ClusterServiceVersionSpecLinks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterServiceVersionSpecMaintainers
 */
export interface ClusterServiceVersionSpecMaintainers {
  /**
   * @schema ClusterServiceVersionSpecMaintainers#email
   */
  readonly email?: string;

  /**
   * @schema ClusterServiceVersionSpecMaintainers#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecMaintainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecMaintainers(obj: ClusterServiceVersionSpecMaintainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'email': obj.email,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GroupVersionKind unambiguously identifies a kind.  It doesn't anonymously include GroupVersion
 * to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling
 *
 * @schema ClusterServiceVersionSpecNativeApIs
 */
export interface ClusterServiceVersionSpecNativeApIs {
  /**
   * @schema ClusterServiceVersionSpecNativeApIs#group
   */
  readonly group: string;

  /**
   * @schema ClusterServiceVersionSpecNativeApIs#kind
   */
  readonly kind: string;

  /**
   * @schema ClusterServiceVersionSpecNativeApIs#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecNativeApIs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecNativeApIs(obj: ClusterServiceVersionSpecNativeApIs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The publishing entity behind the operator.
 *
 * @schema ClusterServiceVersionSpecProvider
 */
export interface ClusterServiceVersionSpecProvider {
  /**
   * @schema ClusterServiceVersionSpecProvider#name
   */
  readonly name?: string;

  /**
   * @schema ClusterServiceVersionSpecProvider#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecProvider(obj: ClusterServiceVersionSpecProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterServiceVersionSpecRelatedImages
 */
export interface ClusterServiceVersionSpecRelatedImages {
  /**
   * @schema ClusterServiceVersionSpecRelatedImages#image
   */
  readonly image: string;

  /**
   * @schema ClusterServiceVersionSpecRelatedImages#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecRelatedImages' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecRelatedImages(obj: ClusterServiceVersionSpecRelatedImages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'image': obj.image,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Label selector for related resources.
 *
 * @schema ClusterServiceVersionSpecSelector
 */
export interface ClusterServiceVersionSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecSelector(obj: ClusterServiceVersionSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WebhookDescription provides details to OLM about required webhooks
 *
 * @schema ClusterServiceVersionSpecWebhookdefinitions
 */
export interface ClusterServiceVersionSpecWebhookdefinitions {
  /**
   * @schema ClusterServiceVersionSpecWebhookdefinitions#admissionReviewVersions
   */
  readonly admissionReviewVersions: string[];

  /**
   * @schema ClusterServiceVersionSpecWebhookdefinitions#containerPort
   */
  readonly containerPort?: number;

  /**
   * @schema ClusterServiceVersionSpecWebhookdefinitions#conversionCRDs
   */
  readonly conversionCrDs?: string[];

  /**
   * @schema ClusterServiceVersionSpecWebhookdefinitions#deploymentName
   */
  readonly deploymentName?: string;

  /**
   * FailurePolicyType specifies a failure policy that defines how unrecognized errors from the admission endpoint are handled.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitions#failurePolicy
   */
  readonly failurePolicy?: string;

  /**
   * @schema ClusterServiceVersionSpecWebhookdefinitions#generateName
   */
  readonly generateName: string;

  /**
   * MatchPolicyType specifies the type of match policy.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitions#matchPolicy
   */
  readonly matchPolicy?: string;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and
   * matchExpressions are ANDed. An empty label selector matches all objects. A null
   * label selector matches no objects.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitions#objectSelector
   */
  readonly objectSelector?: ClusterServiceVersionSpecWebhookdefinitionsObjectSelector;

  /**
   * ReinvocationPolicyType specifies what type of policy the admission hook uses.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitions#reinvocationPolicy
   */
  readonly reinvocationPolicy?: string;

  /**
   * @schema ClusterServiceVersionSpecWebhookdefinitions#rules
   */
  readonly rules?: ClusterServiceVersionSpecWebhookdefinitionsRules[];

  /**
   * SideEffectClass specifies the types of side effects a webhook may have.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitions#sideEffects
   */
  readonly sideEffects: string;

  /**
   * @schema ClusterServiceVersionSpecWebhookdefinitions#targetPort
   */
  readonly targetPort?: ClusterServiceVersionSpecWebhookdefinitionsTargetPort;

  /**
   * @schema ClusterServiceVersionSpecWebhookdefinitions#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

  /**
   * WebhookAdmissionType is the type of admission webhooks supported by OLM
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitions#type
   */
  readonly type: ClusterServiceVersionSpecWebhookdefinitionsType;

  /**
   * @schema ClusterServiceVersionSpecWebhookdefinitions#webhookPath
   */
  readonly webhookPath?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecWebhookdefinitions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecWebhookdefinitions(obj: ClusterServiceVersionSpecWebhookdefinitions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'admissionReviewVersions': obj.admissionReviewVersions?.map(y => y),
    'containerPort': obj.containerPort,
    'conversionCRDs': obj.conversionCrDs?.map(y => y),
    'deploymentName': obj.deploymentName,
    'failurePolicy': obj.failurePolicy,
    'generateName': obj.generateName,
    'matchPolicy': obj.matchPolicy,
    'objectSelector': toJson_ClusterServiceVersionSpecWebhookdefinitionsObjectSelector(obj.objectSelector),
    'reinvocationPolicy': obj.reinvocationPolicy,
    'rules': obj.rules?.map(y => toJson_ClusterServiceVersionSpecWebhookdefinitionsRules(y)),
    'sideEffects': obj.sideEffects,
    'targetPort': obj.targetPort?.value,
    'timeoutSeconds': obj.timeoutSeconds,
    'type': obj.type,
    'webhookPath': obj.webhookPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIServiceDescription provides details to OLM about apis provided via aggregation
 *
 * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned
 */
export interface ClusterServiceVersionSpecApiservicedefinitionsOwned {
  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned#actionDescriptors
   */
  readonly actionDescriptors?: ClusterServiceVersionSpecApiservicedefinitionsOwnedActionDescriptors[];

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned#containerPort
   */
  readonly containerPort?: number;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned#deploymentName
   */
  readonly deploymentName?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned#group
   */
  readonly group: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned#kind
   */
  readonly kind: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned#name
   */
  readonly name: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned#resources
   */
  readonly resources?: ClusterServiceVersionSpecApiservicedefinitionsOwnedResources[];

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned#specDescriptors
   */
  readonly specDescriptors?: ClusterServiceVersionSpecApiservicedefinitionsOwnedSpecDescriptors[];

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned#statusDescriptors
   */
  readonly statusDescriptors?: ClusterServiceVersionSpecApiservicedefinitionsOwnedStatusDescriptors[];

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwned#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecApiservicedefinitionsOwned' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecApiservicedefinitionsOwned(obj: ClusterServiceVersionSpecApiservicedefinitionsOwned | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionDescriptors': obj.actionDescriptors?.map(y => toJson_ClusterServiceVersionSpecApiservicedefinitionsOwnedActionDescriptors(y)),
    'containerPort': obj.containerPort,
    'deploymentName': obj.deploymentName,
    'description': obj.description,
    'displayName': obj.displayName,
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'resources': obj.resources?.map(y => toJson_ClusterServiceVersionSpecApiservicedefinitionsOwnedResources(y)),
    'specDescriptors': obj.specDescriptors?.map(y => toJson_ClusterServiceVersionSpecApiservicedefinitionsOwnedSpecDescriptors(y)),
    'statusDescriptors': obj.statusDescriptors?.map(y => toJson_ClusterServiceVersionSpecApiservicedefinitionsOwnedStatusDescriptors(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIServiceDescription provides details to OLM about apis provided via aggregation
 *
 * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired
 */
export interface ClusterServiceVersionSpecApiservicedefinitionsRequired {
  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired#actionDescriptors
   */
  readonly actionDescriptors?: ClusterServiceVersionSpecApiservicedefinitionsRequiredActionDescriptors[];

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired#containerPort
   */
  readonly containerPort?: number;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired#deploymentName
   */
  readonly deploymentName?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired#group
   */
  readonly group: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired#kind
   */
  readonly kind: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired#name
   */
  readonly name: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired#resources
   */
  readonly resources?: ClusterServiceVersionSpecApiservicedefinitionsRequiredResources[];

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired#specDescriptors
   */
  readonly specDescriptors?: ClusterServiceVersionSpecApiservicedefinitionsRequiredSpecDescriptors[];

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired#statusDescriptors
   */
  readonly statusDescriptors?: ClusterServiceVersionSpecApiservicedefinitionsRequiredStatusDescriptors[];

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequired#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecApiservicedefinitionsRequired' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecApiservicedefinitionsRequired(obj: ClusterServiceVersionSpecApiservicedefinitionsRequired | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionDescriptors': obj.actionDescriptors?.map(y => toJson_ClusterServiceVersionSpecApiservicedefinitionsRequiredActionDescriptors(y)),
    'containerPort': obj.containerPort,
    'deploymentName': obj.deploymentName,
    'description': obj.description,
    'displayName': obj.displayName,
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'resources': obj.resources?.map(y => toJson_ClusterServiceVersionSpecApiservicedefinitionsRequiredResources(y)),
    'specDescriptors': obj.specDescriptors?.map(y => toJson_ClusterServiceVersionSpecApiservicedefinitionsRequiredSpecDescriptors(y)),
    'statusDescriptors': obj.statusDescriptors?.map(y => toJson_ClusterServiceVersionSpecApiservicedefinitionsRequiredStatusDescriptors(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CRDDescription provides details to OLM about the CRDs
 *
 * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwned
 */
export interface ClusterServiceVersionSpecCustomresourcedefinitionsOwned {
  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwned#actionDescriptors
   */
  readonly actionDescriptors?: ClusterServiceVersionSpecCustomresourcedefinitionsOwnedActionDescriptors[];

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwned#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwned#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwned#kind
   */
  readonly kind: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwned#name
   */
  readonly name: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwned#resources
   */
  readonly resources?: ClusterServiceVersionSpecCustomresourcedefinitionsOwnedResources[];

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwned#specDescriptors
   */
  readonly specDescriptors?: ClusterServiceVersionSpecCustomresourcedefinitionsOwnedSpecDescriptors[];

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwned#statusDescriptors
   */
  readonly statusDescriptors?: ClusterServiceVersionSpecCustomresourcedefinitionsOwnedStatusDescriptors[];

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwned#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecCustomresourcedefinitionsOwned' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecCustomresourcedefinitionsOwned(obj: ClusterServiceVersionSpecCustomresourcedefinitionsOwned | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionDescriptors': obj.actionDescriptors?.map(y => toJson_ClusterServiceVersionSpecCustomresourcedefinitionsOwnedActionDescriptors(y)),
    'description': obj.description,
    'displayName': obj.displayName,
    'kind': obj.kind,
    'name': obj.name,
    'resources': obj.resources?.map(y => toJson_ClusterServiceVersionSpecCustomresourcedefinitionsOwnedResources(y)),
    'specDescriptors': obj.specDescriptors?.map(y => toJson_ClusterServiceVersionSpecCustomresourcedefinitionsOwnedSpecDescriptors(y)),
    'statusDescriptors': obj.statusDescriptors?.map(y => toJson_ClusterServiceVersionSpecCustomresourcedefinitionsOwnedStatusDescriptors(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CRDDescription provides details to OLM about the CRDs
 *
 * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequired
 */
export interface ClusterServiceVersionSpecCustomresourcedefinitionsRequired {
  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequired#actionDescriptors
   */
  readonly actionDescriptors?: ClusterServiceVersionSpecCustomresourcedefinitionsRequiredActionDescriptors[];

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequired#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequired#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequired#kind
   */
  readonly kind: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequired#name
   */
  readonly name: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequired#resources
   */
  readonly resources?: ClusterServiceVersionSpecCustomresourcedefinitionsRequiredResources[];

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequired#specDescriptors
   */
  readonly specDescriptors?: ClusterServiceVersionSpecCustomresourcedefinitionsRequiredSpecDescriptors[];

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequired#statusDescriptors
   */
  readonly statusDescriptors?: ClusterServiceVersionSpecCustomresourcedefinitionsRequiredStatusDescriptors[];

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequired#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecCustomresourcedefinitionsRequired' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecCustomresourcedefinitionsRequired(obj: ClusterServiceVersionSpecCustomresourcedefinitionsRequired | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionDescriptors': obj.actionDescriptors?.map(y => toJson_ClusterServiceVersionSpecCustomresourcedefinitionsRequiredActionDescriptors(y)),
    'description': obj.description,
    'displayName': obj.displayName,
    'kind': obj.kind,
    'name': obj.name,
    'resources': obj.resources?.map(y => toJson_ClusterServiceVersionSpecCustomresourcedefinitionsRequiredResources(y)),
    'specDescriptors': obj.specDescriptors?.map(y => toJson_ClusterServiceVersionSpecCustomresourcedefinitionsRequiredSpecDescriptors(y)),
    'statusDescriptors': obj.statusDescriptors?.map(y => toJson_ClusterServiceVersionSpecCustomresourcedefinitionsRequiredStatusDescriptors(y)),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StrategyDetailsDeployment represents the parsed details of a Deployment
 * InstallStrategy.
 *
 * @schema ClusterServiceVersionSpecInstallSpec
 */
export interface ClusterServiceVersionSpecInstallSpec {
  /**
   * @schema ClusterServiceVersionSpecInstallSpec#clusterPermissions
   */
  readonly clusterPermissions?: ClusterServiceVersionSpecInstallSpecClusterPermissions[];

  /**
   * @schema ClusterServiceVersionSpecInstallSpec#deployments
   */
  readonly deployments: ClusterServiceVersionSpecInstallSpecDeployments[];

  /**
   * @schema ClusterServiceVersionSpecInstallSpec#permissions
   */
  readonly permissions?: ClusterServiceVersionSpecInstallSpecPermissions[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpec(obj: ClusterServiceVersionSpecInstallSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterPermissions': obj.clusterPermissions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecClusterPermissions(y)),
    'deployments': obj.deployments?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeployments(y)),
    'permissions': obj.permissions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecPermissions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecSelectorMatchExpressions(obj: ClusterServiceVersionSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema ClusterServiceVersionSpecWebhookdefinitionsObjectSelector
 */
export interface ClusterServiceVersionSpecWebhookdefinitionsObjectSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitionsObjectSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecWebhookdefinitionsObjectSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitionsObjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecWebhookdefinitionsObjectSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecWebhookdefinitionsObjectSelector(obj: ClusterServiceVersionSpecWebhookdefinitionsObjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecWebhookdefinitionsObjectSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RuleWithOperations is a tuple of Operations and Resources. It is recommended to make
 * sure that all the tuple expansions are valid.
 *
 * @schema ClusterServiceVersionSpecWebhookdefinitionsRules
 */
export interface ClusterServiceVersionSpecWebhookdefinitionsRules {
  /**
   * APIGroups is the API groups the resources belong to. '*' is all groups.
   * If '*' is present, the length of the slice must be one.
   * Required.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitionsRules#apiGroups
   */
  readonly apiGroups?: string[];

  /**
   * APIVersions is the API versions the resources belong to. '*' is all versions.
   * If '*' is present, the length of the slice must be one.
   * Required.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitionsRules#apiVersions
   */
  readonly apiVersions?: string[];

  /**
   * Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
   * for all of those operations and any future admission operations that are added.
   * If '*' is present, the length of the slice must be one.
   * Required.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitionsRules#operations
   */
  readonly operations?: string[];

  /**
   * Resources is a list of resources this rule applies to.
   *
   * For example:
   * 'pods' means pods.
   * 'pods/log' means the log subresource of pods.
   * '*' means all resources, but not subresources.
   * 'pods/*' means all subresources of pods.
   * '_/scale' means all scale subresources.
   * '_/*' means all resources and their subresources.
   *
   * If wildcard is present, the validation rule will ensure resources do not
   * overlap with each other.
   *
   * Depending on the enclosing object, subresources might not be allowed.
   * Required.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitionsRules#resources
   */
  readonly resources?: string[];

  /**
   * scope specifies the scope of this rule.
   * Valid values are "Cluster", "Namespaced", and "*"
   * "Cluster" means that only cluster-scoped resources will match this rule.
   * Namespace API objects are cluster-scoped.
   * "Namespaced" means that only namespaced resources will match this rule.
   * "*" means that there are no scope restrictions.
   * Subresources match the scope of their parent resource.
   * Default is "*".
   *
   * @default .
   * @schema ClusterServiceVersionSpecWebhookdefinitionsRules#scope
   */
  readonly scope?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecWebhookdefinitionsRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecWebhookdefinitionsRules(obj: ClusterServiceVersionSpecWebhookdefinitionsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroups': obj.apiGroups?.map(y => y),
    'apiVersions': obj.apiVersions?.map(y => y),
    'operations': obj.operations?.map(y => y),
    'resources': obj.resources?.map(y => y),
    'scope': obj.scope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterServiceVersionSpecWebhookdefinitionsTargetPort
 */
export class ClusterServiceVersionSpecWebhookdefinitionsTargetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecWebhookdefinitionsTargetPort {
    return new ClusterServiceVersionSpecWebhookdefinitionsTargetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecWebhookdefinitionsTargetPort {
    return new ClusterServiceVersionSpecWebhookdefinitionsTargetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * WebhookAdmissionType is the type of admission webhooks supported by OLM
 *
 * @schema ClusterServiceVersionSpecWebhookdefinitionsType
 */
export enum ClusterServiceVersionSpecWebhookdefinitionsType {
  /** ValidatingAdmissionWebhook */
  VALIDATING_ADMISSION_WEBHOOK = "ValidatingAdmissionWebhook",
  /** MutatingAdmissionWebhook */
  MUTATING_ADMISSION_WEBHOOK = "MutatingAdmissionWebhook",
  /** ConversionWebhook */
  CONVERSION_WEBHOOK = "ConversionWebhook",
}

/**
 * ActionDescriptor describes a declarative action that can be performed on a custom resource instance
 *
 * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedActionDescriptors
 */
export interface ClusterServiceVersionSpecApiservicedefinitionsOwnedActionDescriptors {
  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedActionDescriptors#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedActionDescriptors#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedActionDescriptors#path
   */
  readonly path: string;

  /**
   * RawMessage is a raw encoded JSON value.
   * It implements [Marshaler] and [Unmarshaler] and can
   * be used to delay JSON decoding or precompute a JSON encoding.
   *
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedActionDescriptors#value
   */
  readonly value?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedActionDescriptors#x-descriptors
   */
  readonly xDescriptors?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecApiservicedefinitionsOwnedActionDescriptors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecApiservicedefinitionsOwnedActionDescriptors(obj: ClusterServiceVersionSpecApiservicedefinitionsOwnedActionDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'path': obj.path,
    'value': obj.value,
    'x-descriptors': obj.xDescriptors?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIResourceReference is a reference to a Kubernetes resource type that the referrer utilizes.
 *
 * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedResources
 */
export interface ClusterServiceVersionSpecApiservicedefinitionsOwnedResources {
  /**
   * Kind of the referenced resource type.
   *
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedResources#kind
   */
  readonly kind: string;

  /**
   * Plural name of the referenced resource type (CustomResourceDefinition.Spec.Names[].Plural). Empty string if the referenced resource type is not a custom resource.
   *
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedResources#name
   */
  readonly name: string;

  /**
   * API Version of the referenced resource type.
   *
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedResources#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecApiservicedefinitionsOwnedResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecApiservicedefinitionsOwnedResources(obj: ClusterServiceVersionSpecApiservicedefinitionsOwnedResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SpecDescriptor describes a field in a spec block of a CRD so that OLM can consume it
 *
 * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedSpecDescriptors
 */
export interface ClusterServiceVersionSpecApiservicedefinitionsOwnedSpecDescriptors {
  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedSpecDescriptors#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedSpecDescriptors#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedSpecDescriptors#path
   */
  readonly path: string;

  /**
   * RawMessage is a raw encoded JSON value.
   * It implements [Marshaler] and [Unmarshaler] and can
   * be used to delay JSON decoding or precompute a JSON encoding.
   *
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedSpecDescriptors#value
   */
  readonly value?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedSpecDescriptors#x-descriptors
   */
  readonly xDescriptors?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecApiservicedefinitionsOwnedSpecDescriptors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecApiservicedefinitionsOwnedSpecDescriptors(obj: ClusterServiceVersionSpecApiservicedefinitionsOwnedSpecDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'path': obj.path,
    'value': obj.value,
    'x-descriptors': obj.xDescriptors?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatusDescriptor describes a field in a status block of a CRD so that OLM can consume it
 *
 * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedStatusDescriptors
 */
export interface ClusterServiceVersionSpecApiservicedefinitionsOwnedStatusDescriptors {
  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedStatusDescriptors#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedStatusDescriptors#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedStatusDescriptors#path
   */
  readonly path: string;

  /**
   * RawMessage is a raw encoded JSON value.
   * It implements [Marshaler] and [Unmarshaler] and can
   * be used to delay JSON decoding or precompute a JSON encoding.
   *
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedStatusDescriptors#value
   */
  readonly value?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsOwnedStatusDescriptors#x-descriptors
   */
  readonly xDescriptors?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecApiservicedefinitionsOwnedStatusDescriptors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecApiservicedefinitionsOwnedStatusDescriptors(obj: ClusterServiceVersionSpecApiservicedefinitionsOwnedStatusDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'path': obj.path,
    'value': obj.value,
    'x-descriptors': obj.xDescriptors?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ActionDescriptor describes a declarative action that can be performed on a custom resource instance
 *
 * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredActionDescriptors
 */
export interface ClusterServiceVersionSpecApiservicedefinitionsRequiredActionDescriptors {
  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredActionDescriptors#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredActionDescriptors#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredActionDescriptors#path
   */
  readonly path: string;

  /**
   * RawMessage is a raw encoded JSON value.
   * It implements [Marshaler] and [Unmarshaler] and can
   * be used to delay JSON decoding or precompute a JSON encoding.
   *
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredActionDescriptors#value
   */
  readonly value?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredActionDescriptors#x-descriptors
   */
  readonly xDescriptors?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecApiservicedefinitionsRequiredActionDescriptors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecApiservicedefinitionsRequiredActionDescriptors(obj: ClusterServiceVersionSpecApiservicedefinitionsRequiredActionDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'path': obj.path,
    'value': obj.value,
    'x-descriptors': obj.xDescriptors?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIResourceReference is a reference to a Kubernetes resource type that the referrer utilizes.
 *
 * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredResources
 */
export interface ClusterServiceVersionSpecApiservicedefinitionsRequiredResources {
  /**
   * Kind of the referenced resource type.
   *
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredResources#kind
   */
  readonly kind: string;

  /**
   * Plural name of the referenced resource type (CustomResourceDefinition.Spec.Names[].Plural). Empty string if the referenced resource type is not a custom resource.
   *
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredResources#name
   */
  readonly name: string;

  /**
   * API Version of the referenced resource type.
   *
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredResources#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecApiservicedefinitionsRequiredResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecApiservicedefinitionsRequiredResources(obj: ClusterServiceVersionSpecApiservicedefinitionsRequiredResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SpecDescriptor describes a field in a spec block of a CRD so that OLM can consume it
 *
 * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredSpecDescriptors
 */
export interface ClusterServiceVersionSpecApiservicedefinitionsRequiredSpecDescriptors {
  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredSpecDescriptors#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredSpecDescriptors#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredSpecDescriptors#path
   */
  readonly path: string;

  /**
   * RawMessage is a raw encoded JSON value.
   * It implements [Marshaler] and [Unmarshaler] and can
   * be used to delay JSON decoding or precompute a JSON encoding.
   *
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredSpecDescriptors#value
   */
  readonly value?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredSpecDescriptors#x-descriptors
   */
  readonly xDescriptors?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecApiservicedefinitionsRequiredSpecDescriptors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecApiservicedefinitionsRequiredSpecDescriptors(obj: ClusterServiceVersionSpecApiservicedefinitionsRequiredSpecDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'path': obj.path,
    'value': obj.value,
    'x-descriptors': obj.xDescriptors?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatusDescriptor describes a field in a status block of a CRD so that OLM can consume it
 *
 * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredStatusDescriptors
 */
export interface ClusterServiceVersionSpecApiservicedefinitionsRequiredStatusDescriptors {
  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredStatusDescriptors#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredStatusDescriptors#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredStatusDescriptors#path
   */
  readonly path: string;

  /**
   * RawMessage is a raw encoded JSON value.
   * It implements [Marshaler] and [Unmarshaler] and can
   * be used to delay JSON decoding or precompute a JSON encoding.
   *
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredStatusDescriptors#value
   */
  readonly value?: string;

  /**
   * @schema ClusterServiceVersionSpecApiservicedefinitionsRequiredStatusDescriptors#x-descriptors
   */
  readonly xDescriptors?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecApiservicedefinitionsRequiredStatusDescriptors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecApiservicedefinitionsRequiredStatusDescriptors(obj: ClusterServiceVersionSpecApiservicedefinitionsRequiredStatusDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'path': obj.path,
    'value': obj.value,
    'x-descriptors': obj.xDescriptors?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ActionDescriptor describes a declarative action that can be performed on a custom resource instance
 *
 * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedActionDescriptors
 */
export interface ClusterServiceVersionSpecCustomresourcedefinitionsOwnedActionDescriptors {
  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedActionDescriptors#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedActionDescriptors#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedActionDescriptors#path
   */
  readonly path: string;

  /**
   * RawMessage is a raw encoded JSON value.
   * It implements [Marshaler] and [Unmarshaler] and can
   * be used to delay JSON decoding or precompute a JSON encoding.
   *
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedActionDescriptors#value
   */
  readonly value?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedActionDescriptors#x-descriptors
   */
  readonly xDescriptors?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecCustomresourcedefinitionsOwnedActionDescriptors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecCustomresourcedefinitionsOwnedActionDescriptors(obj: ClusterServiceVersionSpecCustomresourcedefinitionsOwnedActionDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'path': obj.path,
    'value': obj.value,
    'x-descriptors': obj.xDescriptors?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIResourceReference is a reference to a Kubernetes resource type that the referrer utilizes.
 *
 * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedResources
 */
export interface ClusterServiceVersionSpecCustomresourcedefinitionsOwnedResources {
  /**
   * Kind of the referenced resource type.
   *
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedResources#kind
   */
  readonly kind: string;

  /**
   * Plural name of the referenced resource type (CustomResourceDefinition.Spec.Names[].Plural). Empty string if the referenced resource type is not a custom resource.
   *
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedResources#name
   */
  readonly name: string;

  /**
   * API Version of the referenced resource type.
   *
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedResources#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecCustomresourcedefinitionsOwnedResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecCustomresourcedefinitionsOwnedResources(obj: ClusterServiceVersionSpecCustomresourcedefinitionsOwnedResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SpecDescriptor describes a field in a spec block of a CRD so that OLM can consume it
 *
 * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedSpecDescriptors
 */
export interface ClusterServiceVersionSpecCustomresourcedefinitionsOwnedSpecDescriptors {
  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedSpecDescriptors#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedSpecDescriptors#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedSpecDescriptors#path
   */
  readonly path: string;

  /**
   * RawMessage is a raw encoded JSON value.
   * It implements [Marshaler] and [Unmarshaler] and can
   * be used to delay JSON decoding or precompute a JSON encoding.
   *
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedSpecDescriptors#value
   */
  readonly value?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedSpecDescriptors#x-descriptors
   */
  readonly xDescriptors?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecCustomresourcedefinitionsOwnedSpecDescriptors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecCustomresourcedefinitionsOwnedSpecDescriptors(obj: ClusterServiceVersionSpecCustomresourcedefinitionsOwnedSpecDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'path': obj.path,
    'value': obj.value,
    'x-descriptors': obj.xDescriptors?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatusDescriptor describes a field in a status block of a CRD so that OLM can consume it
 *
 * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedStatusDescriptors
 */
export interface ClusterServiceVersionSpecCustomresourcedefinitionsOwnedStatusDescriptors {
  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedStatusDescriptors#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedStatusDescriptors#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedStatusDescriptors#path
   */
  readonly path: string;

  /**
   * RawMessage is a raw encoded JSON value.
   * It implements [Marshaler] and [Unmarshaler] and can
   * be used to delay JSON decoding or precompute a JSON encoding.
   *
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedStatusDescriptors#value
   */
  readonly value?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsOwnedStatusDescriptors#x-descriptors
   */
  readonly xDescriptors?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecCustomresourcedefinitionsOwnedStatusDescriptors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecCustomresourcedefinitionsOwnedStatusDescriptors(obj: ClusterServiceVersionSpecCustomresourcedefinitionsOwnedStatusDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'path': obj.path,
    'value': obj.value,
    'x-descriptors': obj.xDescriptors?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ActionDescriptor describes a declarative action that can be performed on a custom resource instance
 *
 * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredActionDescriptors
 */
export interface ClusterServiceVersionSpecCustomresourcedefinitionsRequiredActionDescriptors {
  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredActionDescriptors#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredActionDescriptors#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredActionDescriptors#path
   */
  readonly path: string;

  /**
   * RawMessage is a raw encoded JSON value.
   * It implements [Marshaler] and [Unmarshaler] and can
   * be used to delay JSON decoding or precompute a JSON encoding.
   *
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredActionDescriptors#value
   */
  readonly value?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredActionDescriptors#x-descriptors
   */
  readonly xDescriptors?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecCustomresourcedefinitionsRequiredActionDescriptors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecCustomresourcedefinitionsRequiredActionDescriptors(obj: ClusterServiceVersionSpecCustomresourcedefinitionsRequiredActionDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'path': obj.path,
    'value': obj.value,
    'x-descriptors': obj.xDescriptors?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIResourceReference is a reference to a Kubernetes resource type that the referrer utilizes.
 *
 * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredResources
 */
export interface ClusterServiceVersionSpecCustomresourcedefinitionsRequiredResources {
  /**
   * Kind of the referenced resource type.
   *
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredResources#kind
   */
  readonly kind: string;

  /**
   * Plural name of the referenced resource type (CustomResourceDefinition.Spec.Names[].Plural). Empty string if the referenced resource type is not a custom resource.
   *
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredResources#name
   */
  readonly name: string;

  /**
   * API Version of the referenced resource type.
   *
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredResources#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecCustomresourcedefinitionsRequiredResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecCustomresourcedefinitionsRequiredResources(obj: ClusterServiceVersionSpecCustomresourcedefinitionsRequiredResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SpecDescriptor describes a field in a spec block of a CRD so that OLM can consume it
 *
 * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredSpecDescriptors
 */
export interface ClusterServiceVersionSpecCustomresourcedefinitionsRequiredSpecDescriptors {
  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredSpecDescriptors#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredSpecDescriptors#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredSpecDescriptors#path
   */
  readonly path: string;

  /**
   * RawMessage is a raw encoded JSON value.
   * It implements [Marshaler] and [Unmarshaler] and can
   * be used to delay JSON decoding or precompute a JSON encoding.
   *
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredSpecDescriptors#value
   */
  readonly value?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredSpecDescriptors#x-descriptors
   */
  readonly xDescriptors?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecCustomresourcedefinitionsRequiredSpecDescriptors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecCustomresourcedefinitionsRequiredSpecDescriptors(obj: ClusterServiceVersionSpecCustomresourcedefinitionsRequiredSpecDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'path': obj.path,
    'value': obj.value,
    'x-descriptors': obj.xDescriptors?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatusDescriptor describes a field in a status block of a CRD so that OLM can consume it
 *
 * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredStatusDescriptors
 */
export interface ClusterServiceVersionSpecCustomresourcedefinitionsRequiredStatusDescriptors {
  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredStatusDescriptors#description
   */
  readonly description?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredStatusDescriptors#displayName
   */
  readonly displayName?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredStatusDescriptors#path
   */
  readonly path: string;

  /**
   * RawMessage is a raw encoded JSON value.
   * It implements [Marshaler] and [Unmarshaler] and can
   * be used to delay JSON decoding or precompute a JSON encoding.
   *
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredStatusDescriptors#value
   */
  readonly value?: string;

  /**
   * @schema ClusterServiceVersionSpecCustomresourcedefinitionsRequiredStatusDescriptors#x-descriptors
   */
  readonly xDescriptors?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecCustomresourcedefinitionsRequiredStatusDescriptors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecCustomresourcedefinitionsRequiredStatusDescriptors(obj: ClusterServiceVersionSpecCustomresourcedefinitionsRequiredStatusDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'path': obj.path,
    'value': obj.value,
    'x-descriptors': obj.xDescriptors?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StrategyDeploymentPermissions describe the rbac rules and service account needed by the install strategy
 *
 * @schema ClusterServiceVersionSpecInstallSpecClusterPermissions
 */
export interface ClusterServiceVersionSpecInstallSpecClusterPermissions {
  /**
   * @schema ClusterServiceVersionSpecInstallSpecClusterPermissions#rules
   */
  readonly rules: ClusterServiceVersionSpecInstallSpecClusterPermissionsRules[];

  /**
   * @schema ClusterServiceVersionSpecInstallSpecClusterPermissions#serviceAccountName
   */
  readonly serviceAccountName: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecClusterPermissions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecClusterPermissions(obj: ClusterServiceVersionSpecInstallSpecClusterPermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_ClusterServiceVersionSpecInstallSpecClusterPermissionsRules(y)),
    'serviceAccountName': obj.serviceAccountName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StrategyDeploymentSpec contains the name, spec and labels for the deployment ALM should create
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeployments
 */
export interface ClusterServiceVersionSpecInstallSpecDeployments {
  /**
   * Set is a map of label:value. It implements Labels.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeployments#label
   */
  readonly label?: { [key: string]: string };

  /**
   * @schema ClusterServiceVersionSpecInstallSpecDeployments#name
   */
  readonly name: string;

  /**
   * DeploymentSpec is the specification of the desired behavior of the Deployment.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeployments#spec
   */
  readonly spec: ClusterServiceVersionSpecInstallSpecDeploymentsSpec;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeployments' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeployments(obj: ClusterServiceVersionSpecInstallSpecDeployments | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'label': ((obj.label) === undefined) ? undefined : (Object.entries(obj.label).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'spec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StrategyDeploymentPermissions describe the rbac rules and service account needed by the install strategy
 *
 * @schema ClusterServiceVersionSpecInstallSpecPermissions
 */
export interface ClusterServiceVersionSpecInstallSpecPermissions {
  /**
   * @schema ClusterServiceVersionSpecInstallSpecPermissions#rules
   */
  readonly rules: ClusterServiceVersionSpecInstallSpecPermissionsRules[];

  /**
   * @schema ClusterServiceVersionSpecInstallSpecPermissions#serviceAccountName
   */
  readonly serviceAccountName: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecPermissions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecPermissions(obj: ClusterServiceVersionSpecInstallSpecPermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_ClusterServiceVersionSpecInstallSpecPermissionsRules(y)),
    'serviceAccountName': obj.serviceAccountName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecWebhookdefinitionsObjectSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecWebhookdefinitionsObjectSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitionsObjectSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitionsObjectSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecWebhookdefinitionsObjectSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecWebhookdefinitionsObjectSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecWebhookdefinitionsObjectSelectorMatchExpressions(obj: ClusterServiceVersionSpecWebhookdefinitionsObjectSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PolicyRule holds information that describes a policy rule, but does not contain information
 * about who the rule applies to or which namespace the rule applies to.
 *
 * @schema ClusterServiceVersionSpecInstallSpecClusterPermissionsRules
 */
export interface ClusterServiceVersionSpecInstallSpecClusterPermissionsRules {
  /**
   * APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of
   * the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups.
   *
   * @schema ClusterServiceVersionSpecInstallSpecClusterPermissionsRules#apiGroups
   */
  readonly apiGroups?: string[];

  /**
   * NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path
   * Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
   * Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
   *
   * @schema ClusterServiceVersionSpecInstallSpecClusterPermissionsRules#nonResourceURLs
   */
  readonly nonResourceUrLs?: string[];

  /**
   * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecClusterPermissionsRules#resourceNames
   */
  readonly resourceNames?: string[];

  /**
   * Resources is a list of resources this rule applies to. '*' represents all resources.
   *
   * @schema ClusterServiceVersionSpecInstallSpecClusterPermissionsRules#resources
   */
  readonly resources?: string[];

  /**
   * Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs.
   *
   * @schema ClusterServiceVersionSpecInstallSpecClusterPermissionsRules#verbs
   */
  readonly verbs: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecClusterPermissionsRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecClusterPermissionsRules(obj: ClusterServiceVersionSpecInstallSpecClusterPermissionsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroups': obj.apiGroups?.map(y => y),
    'nonResourceURLs': obj.nonResourceUrLs?.map(y => y),
    'resourceNames': obj.resourceNames?.map(y => y),
    'resources': obj.resources?.map(y => y),
    'verbs': obj.verbs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeploymentSpec is the specification of the desired behavior of the Deployment.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpec {
  /**
   * Minimum number of seconds for which a newly created pod should be ready
   * without any of its container crashing, for it to be considered available.
   * Defaults to 0 (pod will be considered available as soon as it is ready)
   *
   * @default 0 (pod will be considered available as soon as it is ready)
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * Indicates that the deployment is paused.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpec#paused
   */
  readonly paused?: boolean;

  /**
   * The maximum time in seconds for a deployment to make progress before it
   * is considered to be failed. The deployment controller will continue to
   * process failed deployments and a condition with a ProgressDeadlineExceeded
   * reason will be surfaced in the deployment status. Note that progress will
   * not be estimated during the time a deployment is paused. Defaults to 600s.
   *
   * @default 600s.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpec#progressDeadlineSeconds
   */
  readonly progressDeadlineSeconds?: number;

  /**
   * Number of desired pods. This is a pointer to distinguish between explicit
   * zero and not specified. Defaults to 1.
   *
   * @default 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpec#replicas
   */
  readonly replicas?: number;

  /**
   * The number of old ReplicaSets to retain to allow rollback.
   * This is a pointer to distinguish between explicit zero and not specified.
   * Defaults to 10.
   *
   * @default 10.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpec#revisionHistoryLimit
   */
  readonly revisionHistoryLimit?: number;

  /**
   * Label selector for pods. Existing ReplicaSets whose pods are
   * selected by this will be the ones affected by this deployment.
   * It must match the pod template's labels.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpec#selector
   */
  readonly selector: ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelector;

  /**
   * The deployment strategy to use to replace existing pods with new ones.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpec#strategy
   */
  readonly strategy?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategy;

  /**
   * Template describes the pods that will be created.
   * The only allowed template.spec.restartPolicy value is "Always".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpec#template
   */
  readonly template: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplate;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minReadySeconds': obj.minReadySeconds,
    'paused': obj.paused,
    'progressDeadlineSeconds': obj.progressDeadlineSeconds,
    'replicas': obj.replicas,
    'revisionHistoryLimit': obj.revisionHistoryLimit,
    'selector': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelector(obj.selector),
    'strategy': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategy(obj.strategy),
    'template': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PolicyRule holds information that describes a policy rule, but does not contain information
 * about who the rule applies to or which namespace the rule applies to.
 *
 * @schema ClusterServiceVersionSpecInstallSpecPermissionsRules
 */
export interface ClusterServiceVersionSpecInstallSpecPermissionsRules {
  /**
   * APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of
   * the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups.
   *
   * @schema ClusterServiceVersionSpecInstallSpecPermissionsRules#apiGroups
   */
  readonly apiGroups?: string[];

  /**
   * NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path
   * Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
   * Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
   *
   * @schema ClusterServiceVersionSpecInstallSpecPermissionsRules#nonResourceURLs
   */
  readonly nonResourceUrLs?: string[];

  /**
   * ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecPermissionsRules#resourceNames
   */
  readonly resourceNames?: string[];

  /**
   * Resources is a list of resources this rule applies to. '*' represents all resources.
   *
   * @schema ClusterServiceVersionSpecInstallSpecPermissionsRules#resources
   */
  readonly resources?: string[];

  /**
   * Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs.
   *
   * @schema ClusterServiceVersionSpecInstallSpecPermissionsRules#verbs
   */
  readonly verbs: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecPermissionsRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecPermissionsRules(obj: ClusterServiceVersionSpecInstallSpecPermissionsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroups': obj.apiGroups?.map(y => y),
    'nonResourceURLs': obj.nonResourceUrLs?.map(y => y),
    'resourceNames': obj.resourceNames?.map(y => y),
    'resources': obj.resources?.map(y => y),
    'verbs': obj.verbs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Label selector for pods. Existing ReplicaSets whose pods are
 * selected by this will be the ones affected by this deployment.
 * It must match the pod template's labels.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelector
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelector(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The deployment strategy to use to replace existing pods with new ones.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategy
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategy {
  /**
   * Rolling update config params. Present only if DeploymentStrategyType =
   * RollingUpdate.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategy#rollingUpdate
   */
  readonly rollingUpdate?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdate;

  /**
   * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
   *
   * @default RollingUpdate.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategy(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rollingUpdate': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdate(obj.rollingUpdate),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template describes the pods that will be created.
 * The only allowed template.spec.restartPolicy value is "Always".
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplate
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplate {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * Specification of the desired behavior of the pod.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplate#spec
   */
  readonly spec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplate(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelectorMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Rolling update config params. Present only if DeploymentStrategyType =
 * RollingUpdate.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdate
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdate {
  /**
   * The maximum number of pods that can be scheduled above the desired number of
   * pods.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   * Absolute number is calculated from percentage by rounding up.
   * Defaults to 25%.
   * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
   * the rolling update starts, such that the total number of old and new pods do not exceed
   * 130% of desired pods. Once old pods have been killed,
   * new ReplicaSet can be scaled up further, ensuring that total number of pods running
   * at any time during the update is at most 130% of desired pods.
   *
   * @default 25%.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdate#maxSurge
   */
  readonly maxSurge?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxSurge;

  /**
   * The maximum number of pods that can be unavailable during the update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * Absolute number is calculated from percentage by rounding down.
   * This can not be 0 if MaxSurge is 0.
   * Defaults to 25%.
   * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
   * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
   * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
   * that the total number of pods available at all times during the update is at
   * least 70% of desired pods.
   *
   * @default 25%.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxUnavailable;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdate(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification of the desired behavior of the pod.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec {
  /**
   * Optional duration in seconds the pod may be active on the node relative to
   * StartTime before the system will actively try to mark it failed and kill associated containers.
   * Value must be a positive integer.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * If specified, the pod's scheduling constraints
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#affinity
   */
  readonly affinity?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinity;

  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * List of containers belonging to the pod.
   * Containers cannot currently be added or removed.
   * There must be at least one container in a Pod.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#containers
   */
  readonly containers: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers[];

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#dnsConfig
   */
  readonly dnsConfig?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfig;

  /**
   * Set DNS policy for the pod.
   * Defaults to "ClusterFirst".
   * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
   * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
   * To have DNS options set along with hostNetwork, you have to specify DNS policy
   * explicitly to 'ClusterFirstWithHostNet'.
   *
   * @default ClusterFirst".
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * EnableServiceLinks indicates whether information about services should be injected into pod's
   * environment variables, matching the syntax of Docker links.
   * Optional: Defaults to true.
   *
   * @default true.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
   * pod to perform user-initiated actions such as debugging. This list cannot be specified when
   * creating a pod, and it cannot be modified by updating the pod spec. In order to add an
   * ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#ephemeralContainers
   */
  readonly ephemeralContainers?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers[];

  /**
   * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
   * file if specified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#hostAliases
   */
  readonly hostAliases?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecHostAliases[];

  /**
   * Use the host's ipc namespace.
   * Optional: Default to false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#hostIPC
   */
  readonly hostIpc?: boolean;

  /**
   * Host networking requested for this pod. Use the host's network namespace.
   * If this option is set, the ports that will be used must be specified.
   * Default to false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Use the host's pid namespace.
   * Optional: Default to false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#hostPID
   */
  readonly hostPid?: boolean;

  /**
   * Use the host's user namespace.
   * Optional: Default to true.
   * If set to true or not present, the pod will be run in the host user namespace, useful
   * for when the pod needs a feature only available to the host user namespace, such as
   * loading a kernel module with CAP_SYS_MODULE.
   * When set to false, a new userns is created for the pod. Setting false is useful for
   * mitigating container breakout vulnerabilities even allowing users to run their
   * containers as root without actually having root privileges on the host.
   * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
   *
   * @default true.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#hostUsers
   */
  readonly hostUsers?: boolean;

  /**
   * Specifies the hostname of the Pod
   * If not specified, the pod's hostname will be set to a system-defined value.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#hostname
   */
  readonly hostname?: string;

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
   * If specified, these secrets will be passed to individual puller implementations for them to use.
   * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecImagePullSecrets[];

  /**
   * List of initialization containers belonging to the pod.
   * Init containers are executed in order prior to containers being started. If any
   * init container fails, the pod is considered to have failed and is handled according
   * to its restartPolicy. The name for an init container or normal container must be
   * unique among all containers.
   * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
   * The resourceRequirements of an init container are taken into account during scheduling
   * by finding the highest request/limit for each resource type, and then using the max of
   * of that value or the sum of the normal containers. Limits are applied to init containers
   * in a similar fashion.
   * Init containers cannot currently be added or removed.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#initContainers
   */
  readonly initContainers?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers[];

  /**
   * NodeName indicates in which node this pod is scheduled.
   * If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName.
   * Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod.
   * This field should not be used to express a desire for the pod to be scheduled on a specific node.
   * https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#nodeName
   */
  readonly nodeName?: string;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Specifies the OS of the containers in the pod.
   * Some pod and container fields are restricted if this is set.
   *
   * If the OS field is set to linux, the following fields must be unset:
   * -securityContext.windowsOptions
   *
   * If the OS field is set to windows, following fields must be unset:
   * - spec.hostPID
   * - spec.hostIPC
   * - spec.hostUsers
   * - spec.securityContext.appArmorProfile
   * - spec.securityContext.seLinuxOptions
   * - spec.securityContext.seccompProfile
   * - spec.securityContext.fsGroup
   * - spec.securityContext.fsGroupChangePolicy
   * - spec.securityContext.sysctls
   * - spec.shareProcessNamespace
   * - spec.securityContext.runAsUser
   * - spec.securityContext.runAsGroup
   * - spec.securityContext.supplementalGroups
   * - spec.securityContext.supplementalGroupsPolicy
   * - spec.containers[*].securityContext.appArmorProfile
   * - spec.containers[*].securityContext.seLinuxOptions
   * - spec.containers[*].securityContext.seccompProfile
   * - spec.containers[*].securityContext.capabilities
   * - spec.containers[*].securityContext.readOnlyRootFilesystem
   * - spec.containers[*].securityContext.privileged
   * - spec.containers[*].securityContext.allowPrivilegeEscalation
   * - spec.containers[*].securityContext.procMount
   * - spec.containers[*].securityContext.runAsUser
   * - spec.containers[*].securityContext.runAsGroup
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#os
   */
  readonly os?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOs;

  /**
   * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
   * This field will be autopopulated at admission time by the RuntimeClass admission controller. If
   * the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
   * The RuntimeClass admission controller will reject Pod create requests which have the overhead already
   * set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
   * defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#overhead
   */
  readonly overhead?: { [key: string]: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOverhead };

  /**
   * PreemptionPolicy is the Policy for preempting pods with lower priority.
   * One of Never, PreemptLowerPriority.
   * Defaults to PreemptLowerPriority if unset.
   *
   * @default PreemptLowerPriority if unset.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#preemptionPolicy
   */
  readonly preemptionPolicy?: string;

  /**
   * The priority value. Various system components use this field to find the
   * priority of the pod. When Priority Admission Controller is enabled, it
   * prevents users from setting this field. The admission controller populates
   * this field from PriorityClassName.
   * The higher the value, the higher the priority.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#priority
   */
  readonly priority?: number;

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and
   * "system-cluster-critical" are two special keywords which indicate the
   * highest priorities with the former being the highest priority. Any other
   * name must be defined by creating a PriorityClass object with that name.
   * If not specified, the pod priority will be default or zero if there is no
   * default.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * If specified, all readiness gates will be evaluated for pod readiness.
   * A pod is ready when all its containers are ready AND
   * all conditions specified in the readiness gates have status equal to "True"
   * More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#readinessGates
   */
  readonly readinessGates?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecReadinessGates[];

  /**
   * ResourceClaims defines which ResourceClaims must be allocated
   * and reserved before the Pod is allowed to start. The resources
   * will be made available to those containers which consume them
   * by name.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#resourceClaims
   */
  readonly resourceClaims?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourceClaims[];

  /**
   * Resources is the total amount of CPU and Memory resources required by all
   * containers in the pod. It supports specifying Requests and Limits for
   * "cpu" and "memory" resource names only. ResourceClaims are not supported.
   *
   * This field enables fine-grained control over resource allocation for the
   * entire pod, allowing resource sharing among containers in a pod.
   *
   * This is an alpha field and requires enabling the PodLevelResources feature
   * gate.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#resources
   */
  readonly resources?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResources;

  /**
   * Restart policy for all containers within the pod.
   * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
   * Default to Always.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   *
   * @default Always.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
   * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
   * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
   * empty definition that uses the default runtime handler.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * If specified, the pod will be dispatched by specified scheduler.
   * If not specified, the pod will be dispatched by default scheduler.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * SchedulingGates is an opaque list of values that if specified will block scheduling the pod.
   * If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the
   * scheduler will not attempt to schedule the pod.
   *
   * SchedulingGates can only be set at pod creation time, and be removed only afterwards.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#schedulingGates
   */
  readonly schedulingGates?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSchedulingGates[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * Optional: Defaults to empty.  See type description for default values of each field.
   *
   * @default empty.  See type description for default values of each field.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#securityContext
   */
  readonly securityContext?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext;

  /**
   * DeprecatedServiceAccount is a deprecated alias for ServiceAccountName.
   * Deprecated: Use serviceAccountName instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
   * In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
   * In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
   * If a pod does not have FQDN, this has no effect.
   * Default to false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#setHostnameAsFQDN
   */
  readonly setHostnameAsFqdn?: boolean;

  /**
   * Share a single process namespace between all of the containers in a pod.
   * When this is set containers will be able to view and signal processes from other containers
   * in the same pod, and the first process in each container will not be assigned PID 1.
   * HostPID and ShareProcessNamespace cannot both be set.
   * Optional: Default to false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#shareProcessNamespace
   */
  readonly shareProcessNamespace?: boolean;

  /**
   * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
   * If not specified, the pod will not have a domainname at all.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#subdomain
   */
  readonly subdomain?: string;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * If this value is nil, the default grace period will be used instead.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#tolerations
   */
  readonly tolerations?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTolerations[];

  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology
   * domains. Scheduler will schedule pods in a way which abides by the constraints.
   * All topologySpreadConstraints are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints[];

  /**
   * List of volumes that can be mounted by containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec#volumes
   */
  readonly volumes?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activeDeadlineSeconds': obj.activeDeadlineSeconds,
    'affinity': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinity(obj.affinity),
    'automountServiceAccountToken': obj.automountServiceAccountToken,
    'containers': obj.containers?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers(y)),
    'dnsConfig': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'enableServiceLinks': obj.enableServiceLinks,
    'ephemeralContainers': obj.ephemeralContainers?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers(y)),
    'hostAliases': obj.hostAliases?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecHostAliases(y)),
    'hostIPC': obj.hostIpc,
    'hostNetwork': obj.hostNetwork,
    'hostPID': obj.hostPid,
    'hostUsers': obj.hostUsers,
    'hostname': obj.hostname,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecImagePullSecrets(y)),
    'initContainers': obj.initContainers?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers(y)),
    'nodeName': obj.nodeName,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'os': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOs(obj.os),
    'overhead': ((obj.overhead) === undefined) ? undefined : (Object.entries(obj.overhead).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'preemptionPolicy': obj.preemptionPolicy,
    'priority': obj.priority,
    'priorityClassName': obj.priorityClassName,
    'readinessGates': obj.readinessGates?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecReadinessGates(y)),
    'resourceClaims': obj.resourceClaims?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourceClaims(y)),
    'resources': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResources(obj.resources),
    'restartPolicy': obj.restartPolicy,
    'runtimeClassName': obj.runtimeClassName,
    'schedulerName': obj.schedulerName,
    'schedulingGates': obj.schedulingGates?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSchedulingGates(y)),
    'securityContext': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext(obj.securityContext),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountName': obj.serviceAccountName,
    'setHostnameAsFQDN': obj.setHostnameAsFqdn,
    'shareProcessNamespace': obj.shareProcessNamespace,
    'subdomain': obj.subdomain,
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'tolerations': obj.tolerations?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints(y)),
    'volumes': obj.volumes?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The maximum number of pods that can be scheduled above the desired number of
 * pods.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * This can not be 0 if MaxUnavailable is 0.
 * Absolute number is calculated from percentage by rounding up.
 * Defaults to 25%.
 * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
 * the rolling update starts, such that the total number of old and new pods do not exceed
 * 130% of desired pods. Once old pods have been killed,
 * new ReplicaSet can be scaled up further, ensuring that total number of pods running
 * at any time during the update is at most 130% of desired pods.
 *
 * @default 25%.
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxSurge
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxSurge {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxSurge {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxSurge {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be unavailable during the update.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * Absolute number is calculated from percentage by rounding down.
 * This can not be 0 if MaxSurge is 0.
 * Defaults to 25%.
 * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
 * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
 * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
 * that the total number of pods available at all times during the update is at
 * least 70% of desired pods.
 *
 * @default 25%.
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxUnavailable
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxUnavailable {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxUnavailable {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecStrategyRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * If specified, the pod's scheduling constraints
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinity
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinity#podAffinity
   */
  readonly podAffinity?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinity(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#env
   */
  readonly env?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#envFrom
   */
  readonly envFrom?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#lifecycle
   */
  readonly lifecycle?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#livenessProbe
   */
  readonly livenessProbe?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#ports
   */
  readonly ports?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#readinessProbe
   */
  readonly readinessProbe?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#resizePolicy
   */
  readonly resizePolicy?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#resources
   */
  readonly resources?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#securityContext
   */
  readonly securityContext?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#startupProbe
   */
  readonly startupProbe?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#volumeDevices
   */
  readonly volumeDevices?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#volumeMounts
   */
  readonly volumeMounts?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersPorts(y)),
    'readinessProbe': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe(obj.readinessProbe),
    'resizePolicy': obj.resizePolicy?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResizePolicy(y)),
    'resources': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResources(obj.resources),
    'restartPolicy': obj.restartPolicy,
    'securityContext': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfig
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfig#options
   */
  readonly options?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfig(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for
 * user-initiated activities such as debugging. Ephemeral containers have no resource or
 * scheduling guarantees, and they will not be restarted when they exit or when a Pod is
 * removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the
 * Pod to exceed its resource allocation.
 *
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing
 * Pod. Ephemeral containers may not be removed or restarted.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers {
  /**
   * Arguments to the entrypoint.
   * The image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#env
   */
  readonly env?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#envFrom
   */
  readonly envFrom?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#lifecycle
   */
  readonly lifecycle?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecycle;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#livenessProbe
   */
  readonly livenessProbe?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe;

  /**
   * Name of the ephemeral container specified as a DNS_LABEL.
   * This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#name
   */
  readonly name: string;

  /**
   * Ports are not allowed for ephemeral containers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#ports
   */
  readonly ports?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersPorts[];

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#readinessProbe
   */
  readonly readinessProbe?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#resizePolicy
   */
  readonly resizePolicy?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResizePolicy[];

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
   * already allocated to the pod.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#resources
   */
  readonly resources?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResources;

  /**
   * Restart policy for the container to manage the restart behavior of each
   * container within a pod.
   * This may only be set for init containers. You cannot set this field on
   * ephemeral containers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#securityContext
   */
  readonly securityContext?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#startupProbe
   */
  readonly startupProbe?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets.
   * The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
   * If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   *
   * The container runtime must implement support for this feature. If the runtime does not
   * support namespace targeting then the result of setting this field is undefined.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#targetContainerName
   */
  readonly targetContainerName?: string;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#volumeDevices
   */
  readonly volumeDevices?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#volumeMounts
   */
  readonly volumeMounts?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersPorts(y)),
    'readinessProbe': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe(obj.readinessProbe),
    'resizePolicy': obj.resizePolicy?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResizePolicy(y)),
    'resources': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResources(obj.resources),
    'restartPolicy': obj.restartPolicy,
    'securityContext': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'targetContainerName': obj.targetContainerName,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecHostAliases
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecHostAliases#ip
   */
  readonly ip: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecHostAliases(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecImagePullSecrets
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecImagePullSecrets(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#env
   */
  readonly env?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#envFrom
   */
  readonly envFrom?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#lifecycle
   */
  readonly lifecycle?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#ports
   */
  readonly ports?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#resizePolicy
   */
  readonly resizePolicy?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#resources
   */
  readonly resources?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#securityContext
   */
  readonly securityContext?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#startupProbe
   */
  readonly startupProbe?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersPorts(y)),
    'readinessProbe': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe(obj.readinessProbe),
    'resizePolicy': obj.resizePolicy?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResizePolicy(y)),
    'resources': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResources(obj.resources),
    'restartPolicy': obj.restartPolicy,
    'securityContext': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the OS of the containers in the pod.
 * Some pod and container fields are restricted if this is set.
 *
 * If the OS field is set to linux, the following fields must be unset:
 * -securityContext.windowsOptions
 *
 * If the OS field is set to windows, following fields must be unset:
 * - spec.hostPID
 * - spec.hostIPC
 * - spec.hostUsers
 * - spec.securityContext.appArmorProfile
 * - spec.securityContext.seLinuxOptions
 * - spec.securityContext.seccompProfile
 * - spec.securityContext.fsGroup
 * - spec.securityContext.fsGroupChangePolicy
 * - spec.securityContext.sysctls
 * - spec.shareProcessNamespace
 * - spec.securityContext.runAsUser
 * - spec.securityContext.runAsGroup
 * - spec.securityContext.supplementalGroups
 * - spec.securityContext.supplementalGroupsPolicy
 * - spec.containers[*].securityContext.appArmorProfile
 * - spec.containers[*].securityContext.seLinuxOptions
 * - spec.containers[*].securityContext.seccompProfile
 * - spec.containers[*].securityContext.capabilities
 * - spec.containers[*].securityContext.readOnlyRootFilesystem
 * - spec.containers[*].securityContext.privileged
 * - spec.containers[*].securityContext.allowPrivilegeEscalation
 * - spec.containers[*].securityContext.procMount
 * - spec.containers[*].securityContext.runAsUser
 * - spec.containers[*].securityContext.runAsGroup
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOs
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOs {
  /**
   * Name is the name of the operating system. The currently supported values are linux and windows.
   * Additional value may be defined in future and can be one of:
   * https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
   * Clients should expect to handle additional values and treat unrecognized values in this field as os: null
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOs#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOs(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOverhead
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOverhead {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOverhead {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOverhead(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOverhead {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecOverhead(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecReadinessGates
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecReadinessGates#conditionType
   */
  readonly conditionType: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecReadinessGates(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecReadinessGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionType': obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodResourceClaim references exactly one ResourceClaim, either directly
 * or by naming a ResourceClaimTemplate which is then turned into a ResourceClaim
 * for the pod.
 *
 * It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
 * Containers that need access to the ResourceClaim reference it with this name.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourceClaims
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourceClaims {
  /**
   * Name uniquely identifies this resource claim inside the pod.
   * This must be a DNS_LABEL.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourceClaims#name
   */
  readonly name: string;

  /**
   * ResourceClaimName is the name of a ResourceClaim object in the same
   * namespace as this pod.
   *
   * Exactly one of ResourceClaimName and ResourceClaimTemplateName must
   * be set.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourceClaims#resourceClaimName
   */
  readonly resourceClaimName?: string;

  /**
   * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
   * object in the same namespace as this pod.
   *
   * The template will be used to create a new ResourceClaim, which will
   * be bound to this pod. When this pod is deleted, the ResourceClaim
   * will also be deleted. The pod name and resource name, along with a
   * generated component, will be used to form a unique name for the
   * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
   *
   * This field is immutable and no changes will be made to the
   * corresponding ResourceClaim by the control plane after creating the
   * ResourceClaim.
   *
   * Exactly one of ResourceClaimName and ResourceClaimTemplateName must
   * be set.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourceClaims#resourceClaimTemplateName
   */
  readonly resourceClaimTemplateName?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourceClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourceClaims(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourceClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'resourceClaimName': obj.resourceClaimName,
    'resourceClaimTemplateName': obj.resourceClaimTemplateName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources is the total amount of CPU and Memory resources required by all
 * containers in the pod. It supports specifying Requests and Limits for
 * "cpu" and "memory" resource names only. ResourceClaims are not supported.
 *
 * This field enables fine-grained control over resource allocation for the
 * entire pod, allowing resource sharing among containers in a pod.
 *
 * This is an alpha field and requires enabling the PodLevelResources feature
 * gate.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResources
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResources#claims
   */
  readonly claims?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResources(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodSchedulingGate is associated to a Pod to guard its scheduling.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSchedulingGates
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSchedulingGates {
  /**
   * Name of the scheduling gate.
   * Each scheduling gate must have a unique name field.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSchedulingGates#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSchedulingGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSchedulingGates(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSchedulingGates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings.
 * Optional: Defaults to empty.  See type description for default values of each field.
 *
 * @default empty.  See type description for default values of each field.
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#sysctls
   */
  readonly sysctls?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfile': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextAppArmorProfile(obj.appArmorProfile),
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxChangePolicy': obj.seLinuxChangePolicy,
    'seLinuxOptions': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'supplementalGroupsPolicy': obj.supplementalGroupsPolicy,
    'sysctls': obj.sysctls?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSysctls(y)),
    'windowsOptions': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTolerations
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTolerations(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
   * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
   * are redirected to the disk.csi.azure.com CSI driver.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#azureDisk
   */
  readonly azureDisk?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
   * are redirected to the file.csi.azure.com CSI driver.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#azureFile
   */
  readonly azureFile?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
   * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#cephfs
   */
  readonly cephfs?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
   * are redirected to the cinder.csi.openstack.org CSI driver.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#cinder
   */
  readonly cinder?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#configMap
   */
  readonly configMap?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#csi
   */
  readonly csi?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#downwardAPI
   */
  readonly downwardApi?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#emptyDir
   */
  readonly emptyDir?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#ephemeral
   */
  readonly ephemeral?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#fc
   */
  readonly fc?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#flexVolume
   */
  readonly flexVolume?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
   * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#flocker
   */
  readonly flocker?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
   * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#gitRepo
   */
  readonly gitRepo?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#glusterfs
   */
  readonly glusterfs?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#hostPath
   */
  readonly hostPath?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesHostPath;

  /**
   * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
   * The volume is resolved at pod startup depending on which PullPolicy value is provided:
   *
   * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   *
   * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
   * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
   * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
   * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
   * The volume will be mounted read-only (ro) and non-executable files (noexec).
   * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
   * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#image
   */
  readonly image?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesImage;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#iscsi
   */
  readonly iscsi?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#nfs
   */
  readonly nfs?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
   * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
   * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
   * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
   * is on.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#projected
   */
  readonly projected?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
   * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#quobyte
   */
  readonly quobyte?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#rbd
   */
  readonly rbd?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#scaleIO
   */
  readonly scaleIo?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#secret
   */
  readonly secret?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#storageos
   */
  readonly storageos?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
   * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
   * are redirected to the csi.vsphere.vmware.com CSI driver.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesVsphereVolume;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs(obj.cephfs),
    'cinder': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinder(obj.cinder),
    'configMap': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMap(obj.configMap),
    'csi': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsi(obj.csi),
    'downwardAPI': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeral(obj.ephemeral),
    'fc': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFc(obj.fc),
    'flexVolume': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesHostPath(obj.hostPath),
    'image': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesImage(obj.image),
    'iscsi': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjected(obj.projected),
    'quobyte': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte(obj.quobyte),
    'rbd': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd(obj.rbd),
    'scaleIO': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo(obj.scaleIo),
    'secret': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecret(obj.secret),
    'storageos': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinity
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinity(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinity
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinity(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinity
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinity(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnv
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFrom;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnv(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFrom
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFrom(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecycle
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecycle#postStart
   */
  readonly postStart?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecycle#preStop
   */
  readonly preStop?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecycle(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersPorts
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersPorts(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResizePolicy
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResizePolicy(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResizePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceName': obj.resourceName,
    'restartPolicy': obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResources
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResources#claims
   */
  readonly claims?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResources#limits
   */
  readonly limits?: { [key: string]: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResources#requests
   */
  readonly requests?: { [key: string]: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesRequests };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResources(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'appArmorProfile': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextAppArmorProfile(obj.appArmorProfile),
    'capabilities': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe#grpc
   */
  readonly grpc?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeDevices
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeDevices(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfigOptions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfigOptions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnv
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnv#valueFrom
   */
  readonly valueFrom?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFrom;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnv(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFrom
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFrom#secretRef
   */
  readonly secretRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFrom(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Lifecycle is not allowed for ephemeral containers.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecycle
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecycle#postStart
   */
  readonly postStart?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecycle#preStop
   */
  readonly preStop?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecycle(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe#grpc
   */
  readonly grpc?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersPorts
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersPorts(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe#grpc
   */
  readonly grpc?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResizePolicy
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResizePolicy(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResizePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceName': obj.resourceName,
    'restartPolicy': obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
 * already allocated to the pod.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResources
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResources#claims
   */
  readonly claims?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResources#limits
   */
  readonly limits?: { [key: string]: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResources#requests
   */
  readonly requests?: { [key: string]: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesRequests };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResources(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional: SecurityContext defines the security options the ephemeral container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext#capabilities
   */
  readonly capabilities?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'appArmorProfile': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile(obj.appArmorProfile),
    'capabilities': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe#grpc
   */
  readonly grpc?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeDevices
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeDevices(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnv
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFrom;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnv(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFrom
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromSecretRef;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFrom(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecycle
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStop;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecycle(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersPorts
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersPorts(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResizePolicy
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResizePolicy(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResizePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceName': obj.resourceName,
    'restartPolicy': obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResources
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResources#claims
   */
  readonly claims?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResources#limits
   */
  readonly limits?: { [key: string]: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResources#requests
   */
  readonly requests?: { [key: string]: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesRequests };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResources(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'appArmorProfile': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextAppArmorProfile(obj.appArmorProfile),
    'capabilities': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeDevices
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeDevices(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesClaims
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesClaims(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesLimits
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesLimits {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesLimits {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesLimits {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesRequests
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesRequests {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesRequests {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesRequests {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextAppArmorProfile
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextAppArmorProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextAppArmorProfile(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeLinuxOptions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeLinuxOptions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeccompProfile
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeccompProfile(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSysctls
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSysctls(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextWindowsOptions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextWindowsOptions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelector
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelector(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
 * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAwsElasticBlockStore
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAwsElasticBlockStore(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
 * are redirected to the disk.csi.azure.com CSI driver.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
 * are redirected to the file.csi.azure.com CSI driver.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureFile
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureFile(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
 * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
 * are redirected to the cinder.csi.openstack.org CSI driver.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinder
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinder#secretRef
   */
  readonly secretRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinder(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMap
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMap#items
   */
  readonly items?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMap(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsi
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsi(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApi
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApi#items
   */
  readonly items?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApi(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDir
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDir(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeral
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeral(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFc
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFc(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolume
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolume(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
 * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlocker
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlocker(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
 * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGcePersistentDisk
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGcePersistentDisk(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGitRepo
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGitRepo(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGlusterfs
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGlusterfs(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesHostPath
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesHostPath(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
 * The volume is resolved at pod startup depending on which PullPolicy value is provided:
 *
 * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
 * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
 * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
 *
 * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
 * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
 * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
 * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
 * The volume will be mounted read-only (ro) and non-executable files (noexec).
 * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
 * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesImage
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesImage {
  /**
   * Policy for pulling OCI objects. Possible values are:
   * Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Required: Image or artifact reference to be used.
   * Behaves in the same way as pod.spec.containers[*].image.
   * Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesImage#reference
   */
  readonly reference?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesImage(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesNfs
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesNfs(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPersistentVolumeClaim
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPersistentVolumeClaim(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
 * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPhotonPersistentDisk
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPhotonPersistentDisk(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
 * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
 * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
 * is on.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPortworxVolume
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPortworxVolume(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjected
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections. Each entry in this list
   * handles one source.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjected#sources
   */
  readonly sources?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSources[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjected(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
 * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd#secretRef
   */
  readonly secretRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecret
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecret#items
   */
  readonly items?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecret(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageos
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageos(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
 * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
 * are redirected to the csi.vsphere.vmware.com CSI driver.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesVsphereVolume
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesVsphereVolume(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFrom
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFrom(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromConfigMapRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromConfigMapRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromSecretRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromSecretRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStart
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStart#sleep
   */
  readonly sleep?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStart(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    'sleep': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartSleep(obj.sleep),
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStop
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStop#sleep
   */
  readonly sleep?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStop(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    'sleep': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopSleep(obj.sleep),
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeGrpc
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeGrpc(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeGrpc
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeGrpc(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesClaims
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesClaims(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesLimits
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesLimits {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesLimits {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesLimits {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesRequests
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesRequests {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesRequests {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesRequests {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextAppArmorProfile
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextAppArmorProfile(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextCapabilities
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextCapabilities(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeLinuxOptions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeLinuxOptions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeccompProfile
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeccompProfile(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextWindowsOptions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextWindowsOptions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeGrpc
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeGrpc(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFrom
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFrom(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromSecretRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromSecretRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStart
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStart#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStart#sleep
   */
  readonly sleep?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStart(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(obj.httpGet),
    'sleep': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep(obj.sleep),
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStop
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStop#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStop#sleep
   */
  readonly sleep?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStop(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(obj.httpGet),
    'sleep': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep(obj.sleep),
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeGrpc
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeGrpc(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeGrpc
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeGrpc(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesClaims
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesClaims(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesLimits
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesLimits {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesLimits {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesLimits {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesRequests
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesRequests {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesRequests {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesRequests {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextCapabilities
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextCapabilities(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeGrpc
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeGrpc(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFrom
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFrom(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromConfigMapRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromConfigMapRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromSecretRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromSecretRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStart
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStart#sleep
   */
  readonly sleep?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStart(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    'sleep': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartSleep(obj.sleep),
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStop
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStop#sleep
   */
  readonly sleep?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStop(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    'sleep': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopSleep(obj.sleep),
    'tcpSocket': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeGrpc
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeGrpc(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeGrpc
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeGrpc(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesClaims
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesClaims(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesLimits
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesLimits {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesLimits {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesRequests
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesRequests {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesRequests {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextAppArmorProfile
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextAppArmorProfile(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextCapabilities
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextCapabilities(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeccompProfile
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeccompProfile(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextWindowsOptions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextWindowsOptions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeGrpc
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeGrpc(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfsSecretRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfsSecretRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinderSecretRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinderSecretRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMapItems
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMapItems(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsiNodePublishSecretRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsiNodePublishSecretRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItems
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItems(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDirSizeLimit
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDirSizeLimit {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDirSizeLimit {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 * Required, must not be nil.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolumeSecretRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolumeSecretRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsiSecretRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsiSecretRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types.
 * Exactly one of these fields must be set.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSources
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSources#secret
   */
  readonly secret?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSources(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbdSecretRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbdSecretRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIoSecretRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIoSecretRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecretItems
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecretItems(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageosSecretRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageosSecretRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromFieldRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromFieldRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromSecretKeyRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromSecretKeyRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartSleep
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartSleep(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopSleep
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopSleep(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromFieldRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromFieldRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartSleep
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartSleep(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopExec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopExec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGet
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGet(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopSleep
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopSleep(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsFieldRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsFieldRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMap
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMap(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApi
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApi(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecret
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecret(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMapItems
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMapItems(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecretItems
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecretItems(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ClusterServiceVersionSpecInstallSpecDeploymentsSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * InstallPlan defines the installation of a set of operators.
 *
 * @schema InstallPlan
 */
export class InstallPlan extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InstallPlan"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operators.coreos.com/v1alpha1',
    kind: 'InstallPlan',
  }

  /**
   * Renders a Kubernetes manifest for "InstallPlan".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstallPlanProps): any {
    return {
      ...InstallPlan.GVK,
      ...toJson_InstallPlanProps(props),
    };
  }

  /**
   * Defines a "InstallPlan" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstallPlanProps) {
    super(scope, id, {
      ...InstallPlan.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InstallPlan.GVK,
      ...toJson_InstallPlanProps(resolved),
    };
  }
}

/**
 * InstallPlan defines the installation of a set of operators.
 *
 * @schema InstallPlan
 */
export interface InstallPlanProps {
  /**
   * @schema InstallPlan#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * InstallPlanSpec defines a set of Application resources to be installed
   *
   * @schema InstallPlan#spec
   */
  readonly spec: InstallPlanSpec;

}

/**
 * Converts an object of type 'InstallPlanProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_InstallPlanProps(obj: InstallPlanProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstallPlanSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InstallPlanSpec defines a set of Application resources to be installed
 *
 * @schema InstallPlanSpec
 */
export interface InstallPlanSpec {
  /**
   * Approval is the user approval policy for an InstallPlan.
   * It must be one of "Automatic" or "Manual".
   *
   * @schema InstallPlanSpec#approval
   */
  readonly approval: string;

  /**
   * @schema InstallPlanSpec#approved
   */
  readonly approved: boolean;

  /**
   * @schema InstallPlanSpec#clusterServiceVersionNames
   */
  readonly clusterServiceVersionNames: string[];

  /**
   * @schema InstallPlanSpec#generation
   */
  readonly generation?: number;

  /**
   * @schema InstallPlanSpec#source
   */
  readonly source?: string;

  /**
   * @schema InstallPlanSpec#sourceNamespace
   */
  readonly sourceNamespace?: string;

}

/**
 * Converts an object of type 'InstallPlanSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_InstallPlanSpec(obj: InstallPlanSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'approval': obj.approval,
    'approved': obj.approved,
    'clusterServiceVersionNames': obj.clusterServiceVersionNames?.map(y => y),
    'generation': obj.generation,
    'source': obj.source,
    'sourceNamespace': obj.sourceNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * OLMConfig is a resource responsible for configuring OLM.
 *
 * @schema OLMConfig
 */
export class OlmConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OLMConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operators.coreos.com/v1',
    kind: 'OLMConfig',
  }

  /**
   * Renders a Kubernetes manifest for "OLMConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OlmConfigProps): any {
    return {
      ...OlmConfig.GVK,
      ...toJson_OlmConfigProps(props),
    };
  }

  /**
   * Defines a "OLMConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OlmConfigProps) {
    super(scope, id, {
      ...OlmConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OlmConfig.GVK,
      ...toJson_OlmConfigProps(resolved),
    };
  }
}

/**
 * OLMConfig is a resource responsible for configuring OLM.
 *
 * @schema OLMConfig
 */
export interface OlmConfigProps {
  /**
   * @schema OLMConfig#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * OLMConfigSpec is the spec for an OLMConfig resource.
   *
   * @schema OLMConfig#spec
   */
  readonly spec?: OlmConfigSpec;

}

/**
 * Converts an object of type 'OlmConfigProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OlmConfigProps(obj: OlmConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OlmConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OLMConfigSpec is the spec for an OLMConfig resource.
 *
 * @schema OlmConfigSpec
 */
export interface OlmConfigSpec {
  /**
   * Features contains the list of configurable OLM features.
   *
   * @schema OlmConfigSpec#features
   */
  readonly features?: OlmConfigSpecFeatures;

}

/**
 * Converts an object of type 'OlmConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OlmConfigSpec(obj: OlmConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'features': toJson_OlmConfigSpecFeatures(obj.features),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Features contains the list of configurable OLM features.
 *
 * @schema OlmConfigSpecFeatures
 */
export interface OlmConfigSpecFeatures {
  /**
   * DisableCopiedCSVs is used to disable OLM's "Copied CSV" feature
   * for operators installed at the cluster scope, where a cluster
   * scoped operator is one that has been installed in an
   * OperatorGroup that targets all namespaces.
   * When reenabled, OLM will recreate the "Copied CSVs" for each
   * cluster scoped operator.
   *
   * @schema OlmConfigSpecFeatures#disableCopiedCSVs
   */
  readonly disableCopiedCsVs?: boolean;

  /**
   * PackageServerSyncInterval is used to define the sync interval for
   * packagerserver pods. Packageserver pods periodically check the
   * status of CatalogSources; this specifies the period using duration
   * format (e.g. "60m"). For this parameter, only hours ("h"), minutes
   * ("m"), and seconds ("s") may be specified. When not specified, the
   * period defaults to the value specified within the packageserver.
   *
   * @schema OlmConfigSpecFeatures#packageServerSyncInterval
   */
  readonly packageServerSyncInterval?: string;

}

/**
 * Converts an object of type 'OlmConfigSpecFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OlmConfigSpecFeatures(obj: OlmConfigSpecFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableCopiedCSVs': obj.disableCopiedCsVs,
    'packageServerSyncInterval': obj.packageServerSyncInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * Operator represents a cluster operator.
 *
 * @schema Operator
 */
export class Operator extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Operator"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operators.coreos.com/v1',
    kind: 'Operator',
  }

  /**
   * Renders a Kubernetes manifest for "Operator".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OperatorProps = {}): any {
    return {
      ...Operator.GVK,
      ...toJson_OperatorProps(props),
    };
  }

  /**
   * Defines a "Operator" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OperatorProps = {}) {
    super(scope, id, {
      ...Operator.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Operator.GVK,
      ...toJson_OperatorProps(resolved),
    };
  }
}

/**
 * Operator represents a cluster operator.
 *
 * @schema Operator
 */
export interface OperatorProps {
  /**
   * @schema Operator#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OperatorSpec defines the desired state of Operator
   *
   * @schema Operator#spec
   */
  readonly spec?: any;

}

/**
 * Converts an object of type 'OperatorProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorProps(obj: OperatorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * OperatorCondition is a Custom Resource of type `OperatorCondition` which is used to convey information to OLM about the state of an operator.
 *
 * @schema OperatorCondition
 */
export class OperatorCondition extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OperatorCondition"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operators.coreos.com/v1',
    kind: 'OperatorCondition',
  }

  /**
   * Renders a Kubernetes manifest for "OperatorCondition".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OperatorConditionProps): any {
    return {
      ...OperatorCondition.GVK,
      ...toJson_OperatorConditionProps(props),
    };
  }

  /**
   * Defines a "OperatorCondition" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OperatorConditionProps) {
    super(scope, id, {
      ...OperatorCondition.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OperatorCondition.GVK,
      ...toJson_OperatorConditionProps(resolved),
    };
  }
}

/**
 * OperatorCondition is a Custom Resource of type `OperatorCondition` which is used to convey information to OLM about the state of an operator.
 *
 * @schema OperatorCondition
 */
export interface OperatorConditionProps {
  /**
   * @schema OperatorCondition#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * OperatorConditionSpec allows a cluster admin to convey information about the state of an operator to OLM, potentially overriding state reported by the operator.
   *
   * @schema OperatorCondition#spec
   */
  readonly spec?: OperatorConditionSpec;

}

/**
 * Converts an object of type 'OperatorConditionProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorConditionProps(obj: OperatorConditionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OperatorConditionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OperatorConditionSpec allows a cluster admin to convey information about the state of an operator to OLM, potentially overriding state reported by the operator.
 *
 * @schema OperatorConditionSpec
 */
export interface OperatorConditionSpec {
  /**
   * @schema OperatorConditionSpec#deployments
   */
  readonly deployments?: string[];

  /**
   * @schema OperatorConditionSpec#overrides
   */
  readonly overrides?: OperatorConditionSpecOverrides[];

  /**
   * @schema OperatorConditionSpec#serviceAccounts
   */
  readonly serviceAccounts?: string[];

}

/**
 * Converts an object of type 'OperatorConditionSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorConditionSpec(obj: OperatorConditionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deployments': obj.deployments?.map(y => y),
    'overrides': obj.overrides?.map(y => toJson_OperatorConditionSpecOverrides(y)),
    'serviceAccounts': obj.serviceAccounts?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Condition contains details for one aspect of the current state of this API Resource.
 *
 * @schema OperatorConditionSpecOverrides
 */
export interface OperatorConditionSpecOverrides {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   *
   * @schema OperatorConditionSpecOverrides#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   *
   * @schema OperatorConditionSpecOverrides#message
   */
  readonly message: string;

  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   *
   * @schema OperatorConditionSpecOverrides#observedGeneration
   */
  readonly observedGeneration?: number;

  /**
   * reason contains a programmatic identifier indicating the reason for the condition's last transition.
   * Producers of specific condition types may define expected values and meanings for this field,
   * and whether the values are considered a guaranteed API.
   * The value should be a CamelCase string.
   * This field may not be empty.
   *
   * @schema OperatorConditionSpecOverrides#reason
   */
  readonly reason: string;

  /**
   * status of the condition, one of True, False, Unknown.
   *
   * @schema OperatorConditionSpecOverrides#status
   */
  readonly status: OperatorConditionSpecOverridesStatus;

  /**
   * type of condition in CamelCase or in foo.example.com/CamelCase.
   *
   * @schema OperatorConditionSpecOverrides#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'OperatorConditionSpecOverrides' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorConditionSpecOverrides(obj: OperatorConditionSpecOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'observedGeneration': obj.observedGeneration,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * status of the condition, one of True, False, Unknown.
 *
 * @schema OperatorConditionSpecOverridesStatus
 */
export enum OperatorConditionSpecOverridesStatus {
  /** True */
  TRUE = "True",
  /** False */
  FALSE = "False",
  /** Unknown */
  UNKNOWN = "Unknown",
}


/**
 * OperatorCondition is a Custom Resource of type `OperatorCondition` which is used to convey information to OLM about the state of an operator.
 *
 * @schema OperatorConditionV2
 */
export class OperatorConditionV2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OperatorConditionV2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operators.coreos.com/v2',
    kind: 'OperatorCondition',
  }

  /**
   * Renders a Kubernetes manifest for "OperatorConditionV2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OperatorConditionV2Props): any {
    return {
      ...OperatorConditionV2.GVK,
      ...toJson_OperatorConditionV2Props(props),
    };
  }

  /**
   * Defines a "OperatorConditionV2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OperatorConditionV2Props) {
    super(scope, id, {
      ...OperatorConditionV2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OperatorConditionV2.GVK,
      ...toJson_OperatorConditionV2Props(resolved),
    };
  }
}

/**
 * OperatorCondition is a Custom Resource of type `OperatorCondition` which is used to convey information to OLM about the state of an operator.
 *
 * @schema OperatorConditionV2
 */
export interface OperatorConditionV2Props {
  /**
   * @schema OperatorConditionV2#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * OperatorConditionSpec allows an operator to report state to OLM and provides
   * cluster admin with the ability to manually override state reported by the operator.
   *
   * @schema OperatorConditionV2#spec
   */
  readonly spec?: OperatorConditionV2Spec;

}

/**
 * Converts an object of type 'OperatorConditionV2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorConditionV2Props(obj: OperatorConditionV2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OperatorConditionV2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OperatorConditionSpec allows an operator to report state to OLM and provides
 * cluster admin with the ability to manually override state reported by the operator.
 *
 * @schema OperatorConditionV2Spec
 */
export interface OperatorConditionV2Spec {
  /**
   * @schema OperatorConditionV2Spec#conditions
   */
  readonly conditions?: OperatorConditionV2SpecConditions[];

  /**
   * @schema OperatorConditionV2Spec#deployments
   */
  readonly deployments?: string[];

  /**
   * @schema OperatorConditionV2Spec#overrides
   */
  readonly overrides?: OperatorConditionV2SpecOverrides[];

  /**
   * @schema OperatorConditionV2Spec#serviceAccounts
   */
  readonly serviceAccounts?: string[];

}

/**
 * Converts an object of type 'OperatorConditionV2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorConditionV2Spec(obj: OperatorConditionV2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_OperatorConditionV2SpecConditions(y)),
    'deployments': obj.deployments?.map(y => y),
    'overrides': obj.overrides?.map(y => toJson_OperatorConditionV2SpecOverrides(y)),
    'serviceAccounts': obj.serviceAccounts?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Condition contains details for one aspect of the current state of this API Resource.
 *
 * @schema OperatorConditionV2SpecConditions
 */
export interface OperatorConditionV2SpecConditions {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   *
   * @schema OperatorConditionV2SpecConditions#lastTransitionTime
   */
  readonly lastTransitionTime: Date;

  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   *
   * @schema OperatorConditionV2SpecConditions#message
   */
  readonly message: string;

  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   *
   * @schema OperatorConditionV2SpecConditions#observedGeneration
   */
  readonly observedGeneration?: number;

  /**
   * reason contains a programmatic identifier indicating the reason for the condition's last transition.
   * Producers of specific condition types may define expected values and meanings for this field,
   * and whether the values are considered a guaranteed API.
   * The value should be a CamelCase string.
   * This field may not be empty.
   *
   * @schema OperatorConditionV2SpecConditions#reason
   */
  readonly reason: string;

  /**
   * status of the condition, one of True, False, Unknown.
   *
   * @schema OperatorConditionV2SpecConditions#status
   */
  readonly status: OperatorConditionV2SpecConditionsStatus;

  /**
   * type of condition in CamelCase or in foo.example.com/CamelCase.
   *
   * @schema OperatorConditionV2SpecConditions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'OperatorConditionV2SpecConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorConditionV2SpecConditions(obj: OperatorConditionV2SpecConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'observedGeneration': obj.observedGeneration,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Condition contains details for one aspect of the current state of this API Resource.
 *
 * @schema OperatorConditionV2SpecOverrides
 */
export interface OperatorConditionV2SpecOverrides {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   *
   * @schema OperatorConditionV2SpecOverrides#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   *
   * @schema OperatorConditionV2SpecOverrides#message
   */
  readonly message: string;

  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   *
   * @schema OperatorConditionV2SpecOverrides#observedGeneration
   */
  readonly observedGeneration?: number;

  /**
   * reason contains a programmatic identifier indicating the reason for the condition's last transition.
   * Producers of specific condition types may define expected values and meanings for this field,
   * and whether the values are considered a guaranteed API.
   * The value should be a CamelCase string.
   * This field may not be empty.
   *
   * @schema OperatorConditionV2SpecOverrides#reason
   */
  readonly reason: string;

  /**
   * status of the condition, one of True, False, Unknown.
   *
   * @schema OperatorConditionV2SpecOverrides#status
   */
  readonly status: OperatorConditionV2SpecOverridesStatus;

  /**
   * type of condition in CamelCase or in foo.example.com/CamelCase.
   *
   * @schema OperatorConditionV2SpecOverrides#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'OperatorConditionV2SpecOverrides' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorConditionV2SpecOverrides(obj: OperatorConditionV2SpecOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lastTransitionTime': obj.lastTransitionTime?.toISOString(),
    'message': obj.message,
    'observedGeneration': obj.observedGeneration,
    'reason': obj.reason,
    'status': obj.status,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * status of the condition, one of True, False, Unknown.
 *
 * @schema OperatorConditionV2SpecConditionsStatus
 */
export enum OperatorConditionV2SpecConditionsStatus {
  /** True */
  TRUE = "True",
  /** False */
  FALSE = "False",
  /** Unknown */
  UNKNOWN = "Unknown",
}

/**
 * status of the condition, one of True, False, Unknown.
 *
 * @schema OperatorConditionV2SpecOverridesStatus
 */
export enum OperatorConditionV2SpecOverridesStatus {
  /** True */
  TRUE = "True",
  /** False */
  FALSE = "False",
  /** Unknown */
  UNKNOWN = "Unknown",
}


/**
 * OperatorGroup is the unit of multitenancy for OLM managed operators.
It constrains the installation of operators in its namespace to a specified set of target namespaces.
 *
 * @schema OperatorGroup
 */
export class OperatorGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OperatorGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operators.coreos.com/v1',
    kind: 'OperatorGroup',
  }

  /**
   * Renders a Kubernetes manifest for "OperatorGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OperatorGroupProps): any {
    return {
      ...OperatorGroup.GVK,
      ...toJson_OperatorGroupProps(props),
    };
  }

  /**
   * Defines a "OperatorGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OperatorGroupProps) {
    super(scope, id, {
      ...OperatorGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OperatorGroup.GVK,
      ...toJson_OperatorGroupProps(resolved),
    };
  }
}

/**
 * OperatorGroup is the unit of multitenancy for OLM managed operators.
 * It constrains the installation of operators in its namespace to a specified set of target namespaces.
 *
 * @schema OperatorGroup
 */
export interface OperatorGroupProps {
  /**
   * @schema OperatorGroup#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * OperatorGroupSpec is the spec for an OperatorGroup resource.
   *
   * @schema OperatorGroup#spec
   */
  readonly spec?: OperatorGroupSpec;

}

/**
 * Converts an object of type 'OperatorGroupProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorGroupProps(obj: OperatorGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OperatorGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OperatorGroupSpec is the spec for an OperatorGroup resource.
 *
 * @schema OperatorGroupSpec
 */
export interface OperatorGroupSpec {
  /**
   * Selector selects the OperatorGroup's target namespaces.
   *
   * @schema OperatorGroupSpec#selector
   */
  readonly selector?: OperatorGroupSpecSelector;

  /**
   * ServiceAccountName is the admin specified service account which will be
   * used to deploy operator(s) in this operator group.
   *
   * @schema OperatorGroupSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Static tells OLM not to update the OperatorGroup's providedAPIs annotation
   *
   * @schema OperatorGroupSpec#staticProvidedAPIs
   */
  readonly staticProvidedApIs?: boolean;

  /**
   * TargetNamespaces is an explicit set of namespaces to target.
   * If it is set, Selector is ignored.
   *
   * @schema OperatorGroupSpec#targetNamespaces
   */
  readonly targetNamespaces?: string[];

  /**
   * UpgradeStrategy defines the upgrade strategy for operators in the namespace.
   * There are currently two supported upgrade strategies:
   *
   * Default: OLM will only allow clusterServiceVersions to move to the replacing
   * phase from the succeeded phase. This effectively means that OLM will not
   * allow operators to move to the next version if an installation or upgrade
   * has failed.
   *
   * TechPreviewUnsafeFailForward: OLM will allow clusterServiceVersions to move to the
   * replacing phase from the succeeded phase or from the failed phase.
   * Additionally, OLM will generate new installPlans when a subscription references
   * a failed installPlan and the catalog has been updated with a new upgrade for
   * the existing set of operators.
   *
   * WARNING: The TechPreviewUnsafeFailForward upgrade strategy is unsafe and may result
   * in unexpected behavior or unrecoverable data loss unless you have deep
   * understanding of the set of operators being managed in the namespace.
   *
   * @schema OperatorGroupSpec#upgradeStrategy
   */
  readonly upgradeStrategy?: OperatorGroupSpecUpgradeStrategy;

}

/**
 * Converts an object of type 'OperatorGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorGroupSpec(obj: OperatorGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'selector': toJson_OperatorGroupSpecSelector(obj.selector),
    'serviceAccountName': obj.serviceAccountName,
    'staticProvidedAPIs': obj.staticProvidedApIs,
    'targetNamespaces': obj.targetNamespaces?.map(y => y),
    'upgradeStrategy': obj.upgradeStrategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector selects the OperatorGroup's target namespaces.
 *
 * @schema OperatorGroupSpecSelector
 */
export interface OperatorGroupSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema OperatorGroupSpecSelector#matchExpressions
   */
  readonly matchExpressions?: OperatorGroupSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema OperatorGroupSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'OperatorGroupSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorGroupSpecSelector(obj: OperatorGroupSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_OperatorGroupSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UpgradeStrategy defines the upgrade strategy for operators in the namespace.
 * There are currently two supported upgrade strategies:
 *
 * Default: OLM will only allow clusterServiceVersions to move to the replacing
 * phase from the succeeded phase. This effectively means that OLM will not
 * allow operators to move to the next version if an installation or upgrade
 * has failed.
 *
 * TechPreviewUnsafeFailForward: OLM will allow clusterServiceVersions to move to the
 * replacing phase from the succeeded phase or from the failed phase.
 * Additionally, OLM will generate new installPlans when a subscription references
 * a failed installPlan and the catalog has been updated with a new upgrade for
 * the existing set of operators.
 *
 * WARNING: The TechPreviewUnsafeFailForward upgrade strategy is unsafe and may result
 * in unexpected behavior or unrecoverable data loss unless you have deep
 * understanding of the set of operators being managed in the namespace.
 *
 * @schema OperatorGroupSpecUpgradeStrategy
 */
export enum OperatorGroupSpecUpgradeStrategy {
  /** Default */
  DEFAULT = "Default",
  /** TechPreviewUnsafeFailForward */
  TECH_PREVIEW_UNSAFE_FAIL_FORWARD = "TechPreviewUnsafeFailForward",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema OperatorGroupSpecSelectorMatchExpressions
 */
export interface OperatorGroupSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema OperatorGroupSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema OperatorGroupSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema OperatorGroupSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'OperatorGroupSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorGroupSpecSelectorMatchExpressions(obj: OperatorGroupSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * OperatorGroup is the unit of multitenancy for OLM managed operators.
It constrains the installation of operators in its namespace to a specified set of target namespaces.
 *
 * @schema OperatorGroupV1Alpha2
 */
export class OperatorGroupV1Alpha2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OperatorGroupV1Alpha2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operators.coreos.com/v1alpha2',
    kind: 'OperatorGroup',
  }

  /**
   * Renders a Kubernetes manifest for "OperatorGroupV1Alpha2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OperatorGroupV1Alpha2Props): any {
    return {
      ...OperatorGroupV1Alpha2.GVK,
      ...toJson_OperatorGroupV1Alpha2Props(props),
    };
  }

  /**
   * Defines a "OperatorGroupV1Alpha2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OperatorGroupV1Alpha2Props) {
    super(scope, id, {
      ...OperatorGroupV1Alpha2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OperatorGroupV1Alpha2.GVK,
      ...toJson_OperatorGroupV1Alpha2Props(resolved),
    };
  }
}

/**
 * OperatorGroup is the unit of multitenancy for OLM managed operators.
 * It constrains the installation of operators in its namespace to a specified set of target namespaces.
 *
 * @schema OperatorGroupV1Alpha2
 */
export interface OperatorGroupV1Alpha2Props {
  /**
   * @schema OperatorGroupV1Alpha2#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * OperatorGroupSpec is the spec for an OperatorGroup resource.
   *
   * @schema OperatorGroupV1Alpha2#spec
   */
  readonly spec?: OperatorGroupV1Alpha2Spec;

}

/**
 * Converts an object of type 'OperatorGroupV1Alpha2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorGroupV1Alpha2Props(obj: OperatorGroupV1Alpha2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OperatorGroupV1Alpha2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OperatorGroupSpec is the spec for an OperatorGroup resource.
 *
 * @schema OperatorGroupV1Alpha2Spec
 */
export interface OperatorGroupV1Alpha2Spec {
  /**
   * Selector selects the OperatorGroup's target namespaces.
   *
   * @schema OperatorGroupV1Alpha2Spec#selector
   */
  readonly selector?: OperatorGroupV1Alpha2SpecSelector;

  /**
   * ServiceAccountName is the admin specified service account which will be
   * used to deploy operator(s) in this operator group.
   *
   * @schema OperatorGroupV1Alpha2Spec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Static tells OLM not to update the OperatorGroup's providedAPIs annotation
   *
   * @schema OperatorGroupV1Alpha2Spec#staticProvidedAPIs
   */
  readonly staticProvidedApIs?: boolean;

  /**
   * TargetNamespaces is an explicit set of namespaces to target.
   * If it is set, Selector is ignored.
   *
   * @schema OperatorGroupV1Alpha2Spec#targetNamespaces
   */
  readonly targetNamespaces?: string[];

}

/**
 * Converts an object of type 'OperatorGroupV1Alpha2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorGroupV1Alpha2Spec(obj: OperatorGroupV1Alpha2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'selector': toJson_OperatorGroupV1Alpha2SpecSelector(obj.selector),
    'serviceAccountName': obj.serviceAccountName,
    'staticProvidedAPIs': obj.staticProvidedApIs,
    'targetNamespaces': obj.targetNamespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector selects the OperatorGroup's target namespaces.
 *
 * @schema OperatorGroupV1Alpha2SpecSelector
 */
export interface OperatorGroupV1Alpha2SpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema OperatorGroupV1Alpha2SpecSelector#matchExpressions
   */
  readonly matchExpressions?: OperatorGroupV1Alpha2SpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema OperatorGroupV1Alpha2SpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'OperatorGroupV1Alpha2SpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorGroupV1Alpha2SpecSelector(obj: OperatorGroupV1Alpha2SpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_OperatorGroupV1Alpha2SpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema OperatorGroupV1Alpha2SpecSelectorMatchExpressions
 */
export interface OperatorGroupV1Alpha2SpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema OperatorGroupV1Alpha2SpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema OperatorGroupV1Alpha2SpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema OperatorGroupV1Alpha2SpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'OperatorGroupV1Alpha2SpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OperatorGroupV1Alpha2SpecSelectorMatchExpressions(obj: OperatorGroupV1Alpha2SpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * Subscription keeps operators up to date by tracking changes to Catalogs.
 *
 * @schema Subscription
 */
export class Subscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Subscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'operators.coreos.com/v1alpha1',
    kind: 'Subscription',
  }

  /**
   * Renders a Kubernetes manifest for "Subscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubscriptionProps): any {
    return {
      ...Subscription.GVK,
      ...toJson_SubscriptionProps(props),
    };
  }

  /**
   * Defines a "Subscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubscriptionProps) {
    super(scope, id, {
      ...Subscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Subscription.GVK,
      ...toJson_SubscriptionProps(resolved),
    };
  }
}

/**
 * Subscription keeps operators up to date by tracking changes to Catalogs.
 *
 * @schema Subscription
 */
export interface SubscriptionProps {
  /**
   * @schema Subscription#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * SubscriptionSpec defines an Application that can be installed
   *
   * @schema Subscription#spec
   */
  readonly spec: SubscriptionSpec;

}

/**
 * Converts an object of type 'SubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionProps(obj: SubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SubscriptionSpec defines an Application that can be installed
 *
 * @schema SubscriptionSpec
 */
export interface SubscriptionSpec {
  /**
   * @schema SubscriptionSpec#channel
   */
  readonly channel?: string;

  /**
   * SubscriptionConfig contains configuration specified for a subscription.
   *
   * @schema SubscriptionSpec#config
   */
  readonly config?: SubscriptionSpecConfig;

  /**
   * Approval is the user approval policy for an InstallPlan.
   * It must be one of "Automatic" or "Manual".
   *
   * @schema SubscriptionSpec#installPlanApproval
   */
  readonly installPlanApproval?: string;

  /**
   * @schema SubscriptionSpec#name
   */
  readonly name: string;

  /**
   * @schema SubscriptionSpec#source
   */
  readonly source: string;

  /**
   * @schema SubscriptionSpec#sourceNamespace
   */
  readonly sourceNamespace: string;

  /**
   * @schema SubscriptionSpec#startingCSV
   */
  readonly startingCsv?: string;

}

/**
 * Converts an object of type 'SubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpec(obj: SubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'channel': obj.channel,
    'config': toJson_SubscriptionSpecConfig(obj.config),
    'installPlanApproval': obj.installPlanApproval,
    'name': obj.name,
    'source': obj.source,
    'sourceNamespace': obj.sourceNamespace,
    'startingCSV': obj.startingCsv,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SubscriptionConfig contains configuration specified for a subscription.
 *
 * @schema SubscriptionSpecConfig
 */
export interface SubscriptionSpecConfig {
  /**
   * If specified, overrides the pod's scheduling constraints.
   * nil sub-attributes will *not* override the original values in the pod.spec for those sub-attributes.
   * Use empty object ({}) to erase original sub-attribute values.
   *
   * @schema SubscriptionSpecConfig#affinity
   */
  readonly affinity?: SubscriptionSpecConfigAffinity;

  /**
   * Annotations is an unstructured key value map stored with each Deployment, Pod, APIService in the Operator.
   * Typically, annotations may be set by external tools to store and retrieve arbitrary metadata.
   * Use this field to pre-define annotations that OLM should add to each of the Subscription's
   * deployments, pods, and apiservices.
   *
   * @schema SubscriptionSpecConfig#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Env is a list of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema SubscriptionSpecConfig#env
   */
  readonly env?: SubscriptionSpecConfigEnv[];

  /**
   * EnvFrom is a list of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Immutable.
   *
   * @schema SubscriptionSpecConfig#envFrom
   */
  readonly envFrom?: SubscriptionSpecConfigEnvFrom[];

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema SubscriptionSpecConfig#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Resources represents compute resources required by this container.
   * Immutable.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema SubscriptionSpecConfig#resources
   */
  readonly resources?: SubscriptionSpecConfigResources;

  /**
   * Selector is the label selector for pods to be configured.
   * Existing ReplicaSets whose pods are
   * selected by this will be the ones affected by this deployment.
   * It must match the pod template's labels.
   *
   * @schema SubscriptionSpecConfig#selector
   */
  readonly selector?: SubscriptionSpecConfigSelector;

  /**
   * Tolerations are the pod's tolerations.
   *
   * @schema SubscriptionSpecConfig#tolerations
   */
  readonly tolerations?: SubscriptionSpecConfigTolerations[];

  /**
   * List of VolumeMounts to set in the container.
   *
   * @schema SubscriptionSpecConfig#volumeMounts
   */
  readonly volumeMounts?: SubscriptionSpecConfigVolumeMounts[];

  /**
   * List of Volumes to set in the podSpec.
   *
   * @schema SubscriptionSpecConfig#volumes
   */
  readonly volumes?: SubscriptionSpecConfigVolumes[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfig(obj: SubscriptionSpecConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_SubscriptionSpecConfigAffinity(obj.affinity),
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'env': obj.env?.map(y => toJson_SubscriptionSpecConfigEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_SubscriptionSpecConfigEnvFrom(y)),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resources': toJson_SubscriptionSpecConfigResources(obj.resources),
    'selector': toJson_SubscriptionSpecConfigSelector(obj.selector),
    'tolerations': obj.tolerations?.map(y => toJson_SubscriptionSpecConfigTolerations(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_SubscriptionSpecConfigVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => toJson_SubscriptionSpecConfigVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If specified, overrides the pod's scheduling constraints.
 * nil sub-attributes will *not* override the original values in the pod.spec for those sub-attributes.
 * Use empty object ({}) to erase original sub-attribute values.
 *
 * @schema SubscriptionSpecConfigAffinity
 */
export interface SubscriptionSpecConfigAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema SubscriptionSpecConfigAffinity#nodeAffinity
   */
  readonly nodeAffinity?: SubscriptionSpecConfigAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema SubscriptionSpecConfigAffinity#podAffinity
   */
  readonly podAffinity?: SubscriptionSpecConfigAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema SubscriptionSpecConfigAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: SubscriptionSpecConfigAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinity(obj: SubscriptionSpecConfigAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_SubscriptionSpecConfigAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_SubscriptionSpecConfigAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_SubscriptionSpecConfigAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema SubscriptionSpecConfigEnv
 */
export interface SubscriptionSpecConfigEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema SubscriptionSpecConfigEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema SubscriptionSpecConfigEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema SubscriptionSpecConfigEnv#valueFrom
   */
  readonly valueFrom?: SubscriptionSpecConfigEnvValueFrom;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigEnv(obj: SubscriptionSpecConfigEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_SubscriptionSpecConfigEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema SubscriptionSpecConfigEnvFrom
 */
export interface SubscriptionSpecConfigEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema SubscriptionSpecConfigEnvFrom#configMapRef
   */
  readonly configMapRef?: SubscriptionSpecConfigEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema SubscriptionSpecConfigEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema SubscriptionSpecConfigEnvFrom#secretRef
   */
  readonly secretRef?: SubscriptionSpecConfigEnvFromSecretRef;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigEnvFrom(obj: SubscriptionSpecConfigEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_SubscriptionSpecConfigEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_SubscriptionSpecConfigEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources represents compute resources required by this container.
 * Immutable.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
 *
 * @schema SubscriptionSpecConfigResources
 */
export interface SubscriptionSpecConfigResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema SubscriptionSpecConfigResources#claims
   */
  readonly claims?: SubscriptionSpecConfigResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema SubscriptionSpecConfigResources#limits
   */
  readonly limits?: { [key: string]: SubscriptionSpecConfigResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema SubscriptionSpecConfigResources#requests
   */
  readonly requests?: { [key: string]: SubscriptionSpecConfigResourcesRequests };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigResources(obj: SubscriptionSpecConfigResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_SubscriptionSpecConfigResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector is the label selector for pods to be configured.
 * Existing ReplicaSets whose pods are
 * selected by this will be the ones affected by this deployment.
 * It must match the pod template's labels.
 *
 * @schema SubscriptionSpecConfigSelector
 */
export interface SubscriptionSpecConfigSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigSelector#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigSelector(obj: SubscriptionSpecConfigSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema SubscriptionSpecConfigTolerations
 */
export interface SubscriptionSpecConfigTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema SubscriptionSpecConfigTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema SubscriptionSpecConfigTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema SubscriptionSpecConfigTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema SubscriptionSpecConfigTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema SubscriptionSpecConfigTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigTolerations(obj: SubscriptionSpecConfigTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema SubscriptionSpecConfigVolumeMounts
 */
export interface SubscriptionSpecConfigVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema SubscriptionSpecConfigVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema SubscriptionSpecConfigVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema SubscriptionSpecConfigVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema SubscriptionSpecConfigVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema SubscriptionSpecConfigVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema SubscriptionSpecConfigVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema SubscriptionSpecConfigVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumeMounts(obj: SubscriptionSpecConfigVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema SubscriptionSpecConfigVolumes
 */
export interface SubscriptionSpecConfigVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
   * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema SubscriptionSpecConfigVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: SubscriptionSpecConfigVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
   * are redirected to the disk.csi.azure.com CSI driver.
   *
   * @schema SubscriptionSpecConfigVolumes#azureDisk
   */
  readonly azureDisk?: SubscriptionSpecConfigVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
   * are redirected to the file.csi.azure.com CSI driver.
   *
   * @schema SubscriptionSpecConfigVolumes#azureFile
   */
  readonly azureFile?: SubscriptionSpecConfigVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
   * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
   *
   * @schema SubscriptionSpecConfigVolumes#cephfs
   */
  readonly cephfs?: SubscriptionSpecConfigVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
   * are redirected to the cinder.csi.openstack.org CSI driver.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema SubscriptionSpecConfigVolumes#cinder
   */
  readonly cinder?: SubscriptionSpecConfigVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema SubscriptionSpecConfigVolumes#configMap
   */
  readonly configMap?: SubscriptionSpecConfigVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
   *
   * @schema SubscriptionSpecConfigVolumes#csi
   */
  readonly csi?: SubscriptionSpecConfigVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema SubscriptionSpecConfigVolumes#downwardAPI
   */
  readonly downwardApi?: SubscriptionSpecConfigVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema SubscriptionSpecConfigVolumes#emptyDir
   */
  readonly emptyDir?: SubscriptionSpecConfigVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema SubscriptionSpecConfigVolumes#ephemeral
   */
  readonly ephemeral?: SubscriptionSpecConfigVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema SubscriptionSpecConfigVolumes#fc
   */
  readonly fc?: SubscriptionSpecConfigVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
   *
   * @schema SubscriptionSpecConfigVolumes#flexVolume
   */
  readonly flexVolume?: SubscriptionSpecConfigVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
   * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
   *
   * @schema SubscriptionSpecConfigVolumes#flocker
   */
  readonly flocker?: SubscriptionSpecConfigVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
   * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema SubscriptionSpecConfigVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: SubscriptionSpecConfigVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema SubscriptionSpecConfigVolumes#gitRepo
   */
  readonly gitRepo?: SubscriptionSpecConfigVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema SubscriptionSpecConfigVolumes#glusterfs
   */
  readonly glusterfs?: SubscriptionSpecConfigVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema SubscriptionSpecConfigVolumes#hostPath
   */
  readonly hostPath?: SubscriptionSpecConfigVolumesHostPath;

  /**
   * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
   * The volume is resolved at pod startup depending on which PullPolicy value is provided:
   *
   * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   *
   * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
   * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
   * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
   * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
   * The volume will be mounted read-only (ro) and non-executable files (noexec).
   * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
   * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
   *
   * @schema SubscriptionSpecConfigVolumes#image
   */
  readonly image?: SubscriptionSpecConfigVolumesImage;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema SubscriptionSpecConfigVolumes#iscsi
   */
  readonly iscsi?: SubscriptionSpecConfigVolumesIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema SubscriptionSpecConfigVolumes#nfs
   */
  readonly nfs?: SubscriptionSpecConfigVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema SubscriptionSpecConfigVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: SubscriptionSpecConfigVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
   * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
   *
   * @schema SubscriptionSpecConfigVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: SubscriptionSpecConfigVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
   * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
   * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
   * is on.
   *
   * @schema SubscriptionSpecConfigVolumes#portworxVolume
   */
  readonly portworxVolume?: SubscriptionSpecConfigVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema SubscriptionSpecConfigVolumes#projected
   */
  readonly projected?: SubscriptionSpecConfigVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
   * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
   *
   * @schema SubscriptionSpecConfigVolumes#quobyte
   */
  readonly quobyte?: SubscriptionSpecConfigVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema SubscriptionSpecConfigVolumes#rbd
   */
  readonly rbd?: SubscriptionSpecConfigVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
   *
   * @schema SubscriptionSpecConfigVolumes#scaleIO
   */
  readonly scaleIo?: SubscriptionSpecConfigVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema SubscriptionSpecConfigVolumes#secret
   */
  readonly secret?: SubscriptionSpecConfigVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
   *
   * @schema SubscriptionSpecConfigVolumes#storageos
   */
  readonly storageos?: SubscriptionSpecConfigVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
   * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
   * are redirected to the csi.vsphere.vmware.com CSI driver.
   *
   * @schema SubscriptionSpecConfigVolumes#vsphereVolume
   */
  readonly vsphereVolume?: SubscriptionSpecConfigVolumesVsphereVolume;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumes(obj: SubscriptionSpecConfigVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_SubscriptionSpecConfigVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_SubscriptionSpecConfigVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_SubscriptionSpecConfigVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_SubscriptionSpecConfigVolumesCephfs(obj.cephfs),
    'cinder': toJson_SubscriptionSpecConfigVolumesCinder(obj.cinder),
    'configMap': toJson_SubscriptionSpecConfigVolumesConfigMap(obj.configMap),
    'csi': toJson_SubscriptionSpecConfigVolumesCsi(obj.csi),
    'downwardAPI': toJson_SubscriptionSpecConfigVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_SubscriptionSpecConfigVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_SubscriptionSpecConfigVolumesEphemeral(obj.ephemeral),
    'fc': toJson_SubscriptionSpecConfigVolumesFc(obj.fc),
    'flexVolume': toJson_SubscriptionSpecConfigVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_SubscriptionSpecConfigVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_SubscriptionSpecConfigVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_SubscriptionSpecConfigVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_SubscriptionSpecConfigVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_SubscriptionSpecConfigVolumesHostPath(obj.hostPath),
    'image': toJson_SubscriptionSpecConfigVolumesImage(obj.image),
    'iscsi': toJson_SubscriptionSpecConfigVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_SubscriptionSpecConfigVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_SubscriptionSpecConfigVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_SubscriptionSpecConfigVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_SubscriptionSpecConfigVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_SubscriptionSpecConfigVolumesProjected(obj.projected),
    'quobyte': toJson_SubscriptionSpecConfigVolumesQuobyte(obj.quobyte),
    'rbd': toJson_SubscriptionSpecConfigVolumesRbd(obj.rbd),
    'scaleIO': toJson_SubscriptionSpecConfigVolumesScaleIo(obj.scaleIo),
    'secret': toJson_SubscriptionSpecConfigVolumesSecret(obj.secret),
    'storageos': toJson_SubscriptionSpecConfigVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_SubscriptionSpecConfigVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema SubscriptionSpecConfigAffinityNodeAffinity
 */
export interface SubscriptionSpecConfigAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityNodeAffinity(obj: SubscriptionSpecConfigAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema SubscriptionSpecConfigAffinityPodAffinity
 */
export interface SubscriptionSpecConfigAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAffinity(obj: SubscriptionSpecConfigAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema SubscriptionSpecConfigAffinityPodAntiAffinity
 */
export interface SubscriptionSpecConfigAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAntiAffinity(obj: SubscriptionSpecConfigAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema SubscriptionSpecConfigEnvValueFrom
 */
export interface SubscriptionSpecConfigEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema SubscriptionSpecConfigEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: SubscriptionSpecConfigEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema SubscriptionSpecConfigEnvValueFrom#fieldRef
   */
  readonly fieldRef?: SubscriptionSpecConfigEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema SubscriptionSpecConfigEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: SubscriptionSpecConfigEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema SubscriptionSpecConfigEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: SubscriptionSpecConfigEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigEnvValueFrom(obj: SubscriptionSpecConfigEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_SubscriptionSpecConfigEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_SubscriptionSpecConfigEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_SubscriptionSpecConfigEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_SubscriptionSpecConfigEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema SubscriptionSpecConfigEnvFromConfigMapRef
 */
export interface SubscriptionSpecConfigEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema SubscriptionSpecConfigEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigEnvFromConfigMapRef(obj: SubscriptionSpecConfigEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema SubscriptionSpecConfigEnvFromSecretRef
 */
export interface SubscriptionSpecConfigEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema SubscriptionSpecConfigEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigEnvFromSecretRef(obj: SubscriptionSpecConfigEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema SubscriptionSpecConfigResourcesClaims
 */
export interface SubscriptionSpecConfigResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema SubscriptionSpecConfigResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema SubscriptionSpecConfigResourcesClaims#request
   */
  readonly request?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigResourcesClaims(obj: SubscriptionSpecConfigResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubscriptionSpecConfigResourcesLimits
 */
export class SubscriptionSpecConfigResourcesLimits {
  public static fromNumber(value: number): SubscriptionSpecConfigResourcesLimits {
    return new SubscriptionSpecConfigResourcesLimits(value);
  }
  public static fromString(value: string): SubscriptionSpecConfigResourcesLimits {
    return new SubscriptionSpecConfigResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema SubscriptionSpecConfigResourcesRequests
 */
export class SubscriptionSpecConfigResourcesRequests {
  public static fromNumber(value: number): SubscriptionSpecConfigResourcesRequests {
    return new SubscriptionSpecConfigResourcesRequests(value);
  }
  public static fromString(value: string): SubscriptionSpecConfigResourcesRequests {
    return new SubscriptionSpecConfigResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SubscriptionSpecConfigSelectorMatchExpressions
 */
export interface SubscriptionSpecConfigSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SubscriptionSpecConfigSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SubscriptionSpecConfigSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigSelectorMatchExpressions(obj: SubscriptionSpecConfigSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
 * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema SubscriptionSpecConfigVolumesAwsElasticBlockStore
 */
export interface SubscriptionSpecConfigVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema SubscriptionSpecConfigVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema SubscriptionSpecConfigVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema SubscriptionSpecConfigVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema SubscriptionSpecConfigVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesAwsElasticBlockStore(obj: SubscriptionSpecConfigVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
 * are redirected to the disk.csi.azure.com CSI driver.
 *
 * @schema SubscriptionSpecConfigVolumesAzureDisk
 */
export interface SubscriptionSpecConfigVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema SubscriptionSpecConfigVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema SubscriptionSpecConfigVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema SubscriptionSpecConfigVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema SubscriptionSpecConfigVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema SubscriptionSpecConfigVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema SubscriptionSpecConfigVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesAzureDisk(obj: SubscriptionSpecConfigVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
 * are redirected to the file.csi.azure.com CSI driver.
 *
 * @schema SubscriptionSpecConfigVolumesAzureFile
 */
export interface SubscriptionSpecConfigVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema SubscriptionSpecConfigVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema SubscriptionSpecConfigVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema SubscriptionSpecConfigVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesAzureFile(obj: SubscriptionSpecConfigVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
 * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
 *
 * @schema SubscriptionSpecConfigVolumesCephfs
 */
export interface SubscriptionSpecConfigVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema SubscriptionSpecConfigVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema SubscriptionSpecConfigVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema SubscriptionSpecConfigVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema SubscriptionSpecConfigVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema SubscriptionSpecConfigVolumesCephfs#secretRef
   */
  readonly secretRef?: SubscriptionSpecConfigVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema SubscriptionSpecConfigVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesCephfs(obj: SubscriptionSpecConfigVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_SubscriptionSpecConfigVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
 * are redirected to the cinder.csi.openstack.org CSI driver.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema SubscriptionSpecConfigVolumesCinder
 */
export interface SubscriptionSpecConfigVolumesCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema SubscriptionSpecConfigVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema SubscriptionSpecConfigVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema SubscriptionSpecConfigVolumesCinder#secretRef
   */
  readonly secretRef?: SubscriptionSpecConfigVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema SubscriptionSpecConfigVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesCinder(obj: SubscriptionSpecConfigVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_SubscriptionSpecConfigVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema SubscriptionSpecConfigVolumesConfigMap
 */
export interface SubscriptionSpecConfigVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema SubscriptionSpecConfigVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema SubscriptionSpecConfigVolumesConfigMap#items
   */
  readonly items?: SubscriptionSpecConfigVolumesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema SubscriptionSpecConfigVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesConfigMap(obj: SubscriptionSpecConfigVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_SubscriptionSpecConfigVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
 *
 * @schema SubscriptionSpecConfigVolumesCsi
 */
export interface SubscriptionSpecConfigVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema SubscriptionSpecConfigVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema SubscriptionSpecConfigVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema SubscriptionSpecConfigVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: SubscriptionSpecConfigVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema SubscriptionSpecConfigVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema SubscriptionSpecConfigVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesCsi(obj: SubscriptionSpecConfigVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_SubscriptionSpecConfigVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema SubscriptionSpecConfigVolumesDownwardApi
 */
export interface SubscriptionSpecConfigVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema SubscriptionSpecConfigVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema SubscriptionSpecConfigVolumesDownwardApi#items
   */
  readonly items?: SubscriptionSpecConfigVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesDownwardApi(obj: SubscriptionSpecConfigVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_SubscriptionSpecConfigVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema SubscriptionSpecConfigVolumesEmptyDir
 */
export interface SubscriptionSpecConfigVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema SubscriptionSpecConfigVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema SubscriptionSpecConfigVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: SubscriptionSpecConfigVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesEmptyDir(obj: SubscriptionSpecConfigVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema SubscriptionSpecConfigVolumesEphemeral
 */
export interface SubscriptionSpecConfigVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesEphemeral(obj: SubscriptionSpecConfigVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema SubscriptionSpecConfigVolumesFc
 */
export interface SubscriptionSpecConfigVolumesFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema SubscriptionSpecConfigVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema SubscriptionSpecConfigVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema SubscriptionSpecConfigVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema SubscriptionSpecConfigVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema SubscriptionSpecConfigVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesFc(obj: SubscriptionSpecConfigVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
 *
 * @schema SubscriptionSpecConfigVolumesFlexVolume
 */
export interface SubscriptionSpecConfigVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema SubscriptionSpecConfigVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema SubscriptionSpecConfigVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema SubscriptionSpecConfigVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema SubscriptionSpecConfigVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema SubscriptionSpecConfigVolumesFlexVolume#secretRef
   */
  readonly secretRef?: SubscriptionSpecConfigVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesFlexVolume(obj: SubscriptionSpecConfigVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_SubscriptionSpecConfigVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
 * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
 *
 * @schema SubscriptionSpecConfigVolumesFlocker
 */
export interface SubscriptionSpecConfigVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema SubscriptionSpecConfigVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema SubscriptionSpecConfigVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesFlocker(obj: SubscriptionSpecConfigVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
 * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema SubscriptionSpecConfigVolumesGcePersistentDisk
 */
export interface SubscriptionSpecConfigVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema SubscriptionSpecConfigVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema SubscriptionSpecConfigVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema SubscriptionSpecConfigVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema SubscriptionSpecConfigVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesGcePersistentDisk(obj: SubscriptionSpecConfigVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema SubscriptionSpecConfigVolumesGitRepo
 */
export interface SubscriptionSpecConfigVolumesGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema SubscriptionSpecConfigVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema SubscriptionSpecConfigVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema SubscriptionSpecConfigVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesGitRepo(obj: SubscriptionSpecConfigVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema SubscriptionSpecConfigVolumesGlusterfs
 */
export interface SubscriptionSpecConfigVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema SubscriptionSpecConfigVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema SubscriptionSpecConfigVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema SubscriptionSpecConfigVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesGlusterfs(obj: SubscriptionSpecConfigVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 *
 * @schema SubscriptionSpecConfigVolumesHostPath
 */
export interface SubscriptionSpecConfigVolumesHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema SubscriptionSpecConfigVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema SubscriptionSpecConfigVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesHostPath(obj: SubscriptionSpecConfigVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
 * The volume is resolved at pod startup depending on which PullPolicy value is provided:
 *
 * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
 * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
 * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
 *
 * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
 * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
 * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
 * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
 * The volume will be mounted read-only (ro) and non-executable files (noexec).
 * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
 * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
 *
 * @schema SubscriptionSpecConfigVolumesImage
 */
export interface SubscriptionSpecConfigVolumesImage {
  /**
   * Policy for pulling OCI objects. Possible values are:
   * Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema SubscriptionSpecConfigVolumesImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Required: Image or artifact reference to be used.
   * Behaves in the same way as pod.spec.containers[*].image.
   * Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema SubscriptionSpecConfigVolumesImage#reference
   */
  readonly reference?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesImage(obj: SubscriptionSpecConfigVolumesImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema SubscriptionSpecConfigVolumesIscsi
 */
export interface SubscriptionSpecConfigVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema SubscriptionSpecConfigVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema SubscriptionSpecConfigVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   *
   * @schema SubscriptionSpecConfigVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema SubscriptionSpecConfigVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema SubscriptionSpecConfigVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema SubscriptionSpecConfigVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema SubscriptionSpecConfigVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema SubscriptionSpecConfigVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema SubscriptionSpecConfigVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema SubscriptionSpecConfigVolumesIscsi#secretRef
   */
  readonly secretRef?: SubscriptionSpecConfigVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema SubscriptionSpecConfigVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesIscsi(obj: SubscriptionSpecConfigVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_SubscriptionSpecConfigVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema SubscriptionSpecConfigVolumesNfs
 */
export interface SubscriptionSpecConfigVolumesNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema SubscriptionSpecConfigVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema SubscriptionSpecConfigVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema SubscriptionSpecConfigVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesNfs(obj: SubscriptionSpecConfigVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema SubscriptionSpecConfigVolumesPersistentVolumeClaim
 */
export interface SubscriptionSpecConfigVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema SubscriptionSpecConfigVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema SubscriptionSpecConfigVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesPersistentVolumeClaim(obj: SubscriptionSpecConfigVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
 * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
 *
 * @schema SubscriptionSpecConfigVolumesPhotonPersistentDisk
 */
export interface SubscriptionSpecConfigVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema SubscriptionSpecConfigVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema SubscriptionSpecConfigVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesPhotonPersistentDisk(obj: SubscriptionSpecConfigVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
 * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
 * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
 * is on.
 *
 * @schema SubscriptionSpecConfigVolumesPortworxVolume
 */
export interface SubscriptionSpecConfigVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema SubscriptionSpecConfigVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema SubscriptionSpecConfigVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema SubscriptionSpecConfigVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesPortworxVolume(obj: SubscriptionSpecConfigVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema SubscriptionSpecConfigVolumesProjected
 */
export interface SubscriptionSpecConfigVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema SubscriptionSpecConfigVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections. Each entry in this list
   * handles one source.
   *
   * @schema SubscriptionSpecConfigVolumesProjected#sources
   */
  readonly sources?: SubscriptionSpecConfigVolumesProjectedSources[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjected(obj: SubscriptionSpecConfigVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_SubscriptionSpecConfigVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
 * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
 *
 * @schema SubscriptionSpecConfigVolumesQuobyte
 */
export interface SubscriptionSpecConfigVolumesQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema SubscriptionSpecConfigVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema SubscriptionSpecConfigVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema SubscriptionSpecConfigVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema SubscriptionSpecConfigVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema SubscriptionSpecConfigVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema SubscriptionSpecConfigVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesQuobyte(obj: SubscriptionSpecConfigVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema SubscriptionSpecConfigVolumesRbd
 */
export interface SubscriptionSpecConfigVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   *
   * @schema SubscriptionSpecConfigVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema SubscriptionSpecConfigVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema SubscriptionSpecConfigVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema SubscriptionSpecConfigVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema SubscriptionSpecConfigVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema SubscriptionSpecConfigVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema SubscriptionSpecConfigVolumesRbd#secretRef
   */
  readonly secretRef?: SubscriptionSpecConfigVolumesRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema SubscriptionSpecConfigVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesRbd(obj: SubscriptionSpecConfigVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_SubscriptionSpecConfigVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
 *
 * @schema SubscriptionSpecConfigVolumesScaleIo
 */
export interface SubscriptionSpecConfigVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema SubscriptionSpecConfigVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema SubscriptionSpecConfigVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema SubscriptionSpecConfigVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema SubscriptionSpecConfigVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema SubscriptionSpecConfigVolumesScaleIo#secretRef
   */
  readonly secretRef: SubscriptionSpecConfigVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema SubscriptionSpecConfigVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema SubscriptionSpecConfigVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema SubscriptionSpecConfigVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema SubscriptionSpecConfigVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema SubscriptionSpecConfigVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesScaleIo(obj: SubscriptionSpecConfigVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_SubscriptionSpecConfigVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema SubscriptionSpecConfigVolumesSecret
 */
export interface SubscriptionSpecConfigVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema SubscriptionSpecConfigVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema SubscriptionSpecConfigVolumesSecret#items
   */
  readonly items?: SubscriptionSpecConfigVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema SubscriptionSpecConfigVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema SubscriptionSpecConfigVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesSecret(obj: SubscriptionSpecConfigVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_SubscriptionSpecConfigVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
 *
 * @schema SubscriptionSpecConfigVolumesStorageos
 */
export interface SubscriptionSpecConfigVolumesStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema SubscriptionSpecConfigVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema SubscriptionSpecConfigVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema SubscriptionSpecConfigVolumesStorageos#secretRef
   */
  readonly secretRef?: SubscriptionSpecConfigVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema SubscriptionSpecConfigVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema SubscriptionSpecConfigVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesStorageos(obj: SubscriptionSpecConfigVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_SubscriptionSpecConfigVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
 * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
 * are redirected to the csi.vsphere.vmware.com CSI driver.
 *
 * @schema SubscriptionSpecConfigVolumesVsphereVolume
 */
export interface SubscriptionSpecConfigVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema SubscriptionSpecConfigVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema SubscriptionSpecConfigVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema SubscriptionSpecConfigVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema SubscriptionSpecConfigVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesVsphereVolume(obj: SubscriptionSpecConfigVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema SubscriptionSpecConfigEnvValueFromConfigMapKeyRef
 */
export interface SubscriptionSpecConfigEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema SubscriptionSpecConfigEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema SubscriptionSpecConfigEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigEnvValueFromConfigMapKeyRef(obj: SubscriptionSpecConfigEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema SubscriptionSpecConfigEnvValueFromFieldRef
 */
export interface SubscriptionSpecConfigEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema SubscriptionSpecConfigEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema SubscriptionSpecConfigEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigEnvValueFromFieldRef(obj: SubscriptionSpecConfigEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema SubscriptionSpecConfigEnvValueFromResourceFieldRef
 */
export interface SubscriptionSpecConfigEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema SubscriptionSpecConfigEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema SubscriptionSpecConfigEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: SubscriptionSpecConfigEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema SubscriptionSpecConfigEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigEnvValueFromResourceFieldRef(obj: SubscriptionSpecConfigEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema SubscriptionSpecConfigEnvValueFromSecretKeyRef
 */
export interface SubscriptionSpecConfigEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema SubscriptionSpecConfigEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema SubscriptionSpecConfigEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigEnvValueFromSecretKeyRef(obj: SubscriptionSpecConfigEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema SubscriptionSpecConfigVolumesCephfsSecretRef
 */
export interface SubscriptionSpecConfigVolumesCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesCephfsSecretRef(obj: SubscriptionSpecConfigVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema SubscriptionSpecConfigVolumesCinderSecretRef
 */
export interface SubscriptionSpecConfigVolumesCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesCinderSecretRef(obj: SubscriptionSpecConfigVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema SubscriptionSpecConfigVolumesConfigMapItems
 */
export interface SubscriptionSpecConfigVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema SubscriptionSpecConfigVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema SubscriptionSpecConfigVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema SubscriptionSpecConfigVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesConfigMapItems(obj: SubscriptionSpecConfigVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema SubscriptionSpecConfigVolumesCsiNodePublishSecretRef
 */
export interface SubscriptionSpecConfigVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesCsiNodePublishSecretRef(obj: SubscriptionSpecConfigVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema SubscriptionSpecConfigVolumesDownwardApiItems
 */
export interface SubscriptionSpecConfigVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema SubscriptionSpecConfigVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: SubscriptionSpecConfigVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema SubscriptionSpecConfigVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema SubscriptionSpecConfigVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema SubscriptionSpecConfigVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesDownwardApiItems(obj: SubscriptionSpecConfigVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_SubscriptionSpecConfigVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema SubscriptionSpecConfigVolumesEmptyDirSizeLimit
 */
export class SubscriptionSpecConfigVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): SubscriptionSpecConfigVolumesEmptyDirSizeLimit {
    return new SubscriptionSpecConfigVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): SubscriptionSpecConfigVolumesEmptyDirSizeLimit {
    return new SubscriptionSpecConfigVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 * Required, must not be nil.
 *
 * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplate
 */
export interface SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplate(obj: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema SubscriptionSpecConfigVolumesFlexVolumeSecretRef
 */
export interface SubscriptionSpecConfigVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesFlexVolumeSecretRef(obj: SubscriptionSpecConfigVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema SubscriptionSpecConfigVolumesIscsiSecretRef
 */
export interface SubscriptionSpecConfigVolumesIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesIscsiSecretRef(obj: SubscriptionSpecConfigVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types.
 * Exactly one of these fields must be set.
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSources
 */
export interface SubscriptionSpecConfigVolumesProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSources#configMap
   */
  readonly configMap?: SubscriptionSpecConfigVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: SubscriptionSpecConfigVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSources#secret
   */
  readonly secret?: SubscriptionSpecConfigVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: SubscriptionSpecConfigVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSources(obj: SubscriptionSpecConfigVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_SubscriptionSpecConfigVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_SubscriptionSpecConfigVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_SubscriptionSpecConfigVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_SubscriptionSpecConfigVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema SubscriptionSpecConfigVolumesRbdSecretRef
 */
export interface SubscriptionSpecConfigVolumesRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesRbdSecretRef(obj: SubscriptionSpecConfigVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema SubscriptionSpecConfigVolumesScaleIoSecretRef
 */
export interface SubscriptionSpecConfigVolumesScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesScaleIoSecretRef(obj: SubscriptionSpecConfigVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema SubscriptionSpecConfigVolumesSecretItems
 */
export interface SubscriptionSpecConfigVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema SubscriptionSpecConfigVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema SubscriptionSpecConfigVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema SubscriptionSpecConfigVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesSecretItems(obj: SubscriptionSpecConfigVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema SubscriptionSpecConfigVolumesStorageosSecretRef
 */
export interface SubscriptionSpecConfigVolumesStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesStorageosSecretRef(obj: SubscriptionSpecConfigVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema SubscriptionSpecConfigEnvValueFromResourceFieldRefDivisor
 */
export class SubscriptionSpecConfigEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): SubscriptionSpecConfigEnvValueFromResourceFieldRefDivisor {
    return new SubscriptionSpecConfigEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): SubscriptionSpecConfigEnvValueFromResourceFieldRefDivisor {
    return new SubscriptionSpecConfigEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema SubscriptionSpecConfigVolumesDownwardApiItemsFieldRef
 */
export interface SubscriptionSpecConfigVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema SubscriptionSpecConfigVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema SubscriptionSpecConfigVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesDownwardApiItemsFieldRef(obj: SubscriptionSpecConfigVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRef
 */
export interface SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRef(obj: SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec(obj: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundle
 */
export interface SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundle(obj: SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesConfigMap
 */
export interface SubscriptionSpecConfigVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: SubscriptionSpecConfigVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSourcesConfigMap(obj: SubscriptionSpecConfigVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_SubscriptionSpecConfigVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApi
 */
export interface SubscriptionSpecConfigVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSourcesDownwardApi(obj: SubscriptionSpecConfigVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesSecret
 */
export interface SubscriptionSpecConfigVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesSecret#items
   */
  readonly items?: SubscriptionSpecConfigVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSourcesSecret(obj: SubscriptionSpecConfigVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_SubscriptionSpecConfigVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesServiceAccountToken
 */
export interface SubscriptionSpecConfigVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSourcesServiceAccountToken(obj: SubscriptionSpecConfigVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: SubscriptionSpecConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: SubscriptionSpecConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: SubscriptionSpecConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: SubscriptionSpecConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new SubscriptionSpecConfigVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResources(obj: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelector(obj: SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesConfigMapItems
 */
export interface SubscriptionSpecConfigVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSourcesConfigMapItems(obj: SubscriptionSpecConfigVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItems
 */
export interface SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItems(obj: SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesSecretItems
 */
export interface SubscriptionSpecConfigVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSourcesSecretItems(obj: SubscriptionSpecConfigVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: SubscriptionSpecConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: SubscriptionSpecConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: SubscriptionSpecConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: SubscriptionSpecConfigVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new SubscriptionSpecConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

